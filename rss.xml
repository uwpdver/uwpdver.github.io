<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[要没时间了的博客]]></title><description><![CDATA[分享知识和生活，记录成长与感动。]]></description><link>https://blog-ak8.pages.dev</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 04 Dec 2022 10:33:52 GMT</lastBuildDate><item><title><![CDATA[将博客迁移到 GitHub Pages]]></title><description><![CDATA[之前这个博客是托管在 Cloudflare Pages 上的，通过 GitHub Apps 让 Github 仓库和 Cloudflare Pages 关联，使得被关联的仓库在每次被 push 了新的提交，就会触发 Cloudflare Pages…]]></description><link>https://blog-ak8.pages.dev/将博客迁移到 GitHub Pages/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/将博客迁移到 GitHub Pages/</guid><pubDate>Thu, 25 Nov 2021 23:28:00 GMT</pubDate><content:encoded>&lt;p&gt;之前这个博客是托管在 Cloudflare Pages 上的，通过 GitHub Apps 让 Github 仓库和 Cloudflare Pages 关联，使得被关联的仓库在每次被 push 了新的提交，就会触发 Cloudflare Pages 的自动化部署操作，并且将构建好的 html 等静态文件托管在 Cloudflare 的服务器上。&lt;/p&gt;
&lt;p&gt;Github 也提供了类似的 Github Pages 服务。而且Github Action 也可以用来自动化部署，在 Action 市场里就有一个现成的自动化部署 Gatsby 项目到 Github Pages 的 Action，叫做 Gatsby Publish。&lt;/p&gt;
&lt;p&gt;按照 Gatsby Publish 的文档，使用起来不难，但是有一些地方要注意。&lt;/p&gt;
&lt;h3&gt;access token&lt;/h3&gt;
&lt;p&gt;在 Gatsby Publish 配置中，有一个 &lt;code class=&quot;language-text&quot;&gt;${{secrets.ACCESS_TOKEN}}&lt;/code&gt; 的写法。这里的 &lt;code class=&quot;language-text&quot;&gt;secrets&lt;/code&gt; 是 Action 在运行时可以访问到上下文的一个变量，这些变量在仓库的设置页面的 Secrets 菜单中添加。access token 是用来授权的，也需要在 &lt;a href=&quot;https://github.com/settings/tokens&quot;&gt;Github Personal Access Tokens 管理页面&lt;/a&gt; 手动生成。并且将生成的 access token 添加到仓库的 secrets 中，注意变量名是 ACCESS_TOKEN。access token 默认会过期，access token 过期了自动部署脚本的运行会发生错误，为了方便可以将其设置为永不过期。&lt;/p&gt;
&lt;h3&gt;deploy-repo&lt;/h3&gt;
&lt;p&gt;这是指定要部署到的仓库，不特别指定的话默认部署到当前仓库。我的博客项目仓库和要部署的 Github Pages 仓库不是同一个，所以需要将这个值设置为我的 Github Pages 对应的仓库名。&lt;/p&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/marketplace/actions/gatsby-publish&quot;&gt;Gatsby Publish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/364366127&quot;&gt;GitHub Actions入门教程-自动部署静态博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[构建你自己的 react]]></title><description><![CDATA[原文：Build your own React 作者：Rodrigo Pombo createElement 函数 元素 元素是对要显示在屏幕上的东西的描述。在内部表示其实就是一个普通的 JavaScript 对象。包含三个重要的属性： type：标识元素的类型。 props…]]></description><link>https://blog-ak8.pages.dev/构建你自己的 react/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/构建你自己的 react/</guid><pubDate>Thu, 11 Nov 2021 15:25:00 GMT</pubDate><content:encoded>&lt;p&gt;原文：&lt;a href=&quot;https://pomb.us/build-your-own-react/&quot;&gt;Build your own React&lt;/a&gt;&lt;br&gt;
作者：&lt;a href=&quot;https://twitter.com/pomber&quot;&gt;Rodrigo Pombo&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;createElement 函数&lt;/h2&gt;
&lt;h3&gt;元素&lt;/h3&gt;
&lt;p&gt;元素是对要显示在屏幕上的东西的描述。在内部表示其实就是一个普通的 JavaScript 对象。包含三个重要的属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;type：标识元素的类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;props：元素的一些属性，如果是 HTML 标签则与 HTML 元素的 &lt;code class=&quot;language-text&quot;&gt;attribute&lt;/code&gt; 对应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;children：元素的子元素列表。代表当前元素所包含的所有元素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; element &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;h1&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        title&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;  
        children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;创建元素&lt;/h3&gt;
&lt;p&gt;为了避免每次创建函数都手写一个对象字面量。我们可以通过函数来创建元素对象。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;children&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; children&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;child&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还需要创建不包括子元素的文本元素。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createTextElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;TEXT_ELEMENT&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            nodeValue&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; text&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;render 函数&lt;/h2&gt;
&lt;p&gt;将元素所描述的内容显示在屏幕上。&lt;/p&gt;
&lt;h2&gt;并发模式&lt;/h2&gt;
&lt;p&gt;递归地渲染元素可能导致 JavaScript 运行时间过长，主线程被阻塞过久导致无法即使响应用户输入或者导致动画丢帧。&lt;/p&gt;
&lt;p&gt;因为递归渲染过程中采用栈结构（调用栈）追踪每一个子渲染过程，渲染到某个子渲染过程中时，无法在保留当前渲染所需的状态的同时切换到另一个任务。&lt;/p&gt;
&lt;p&gt;我们需要将渲染过程拆分成多个小的独立的工作单元，让每个工作单元完成后都可以中断，去做其他的更紧急的任务。当主线程空闲时再从之前工作中断处继续执行渲染工作。&lt;/p&gt;
&lt;h2&gt;Fibers&lt;/h2&gt;
&lt;p&gt;为了组织工作单元，需要一个数据结构：一个 fiber 节点。&lt;/p&gt;
&lt;p&gt;每个元素都有一个 fiber，每个 fiber 都是一个工作单元。&lt;/p&gt;
&lt;p&gt;fiber 数据结构的一个目的就是让能够更容易找到下一个工作单元。fiber 内有三个指针，分别指向三个不同关系的 fiber 节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;return: 当前节点的父节点。&lt;/li&gt;
&lt;li&gt;child: 当前节点的第一个子节点。&lt;/li&gt;
&lt;li&gt;sibling: 与当前节点相邻的下一个节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;fiber 之间彼此通过这些指针相连接，类似链表的结构。这样相当于把遍历元素的过程从之前递归拍平成了循环。好处是这个循环过程可以被中断，我们可以保存下当前循环的状态，以供将来恢复。&lt;/p&gt;
&lt;h2&gt;渲染（Render）和提交（Commit）阶段&lt;/h2&gt;
&lt;p&gt;如果每次处理一个工作单元都创建并添加一个 DOM 节点到 DOM 树中，那么用户就会看到未完成的界面，这样会影响用户体验。&lt;/p&gt;
&lt;p&gt;为了避免这种情况，我们可以将整个更新 UI 的过程分成渲染和提交两个阶段。渲染阶段专注于根据元素的描述和当前的状态计算下一阶段要做的一系列 DOM 操作，而提交阶段则专注于根据渲染阶段所得的结果来操作 DOM。&lt;/p&gt;
&lt;p&gt;渲染阶段的工作可以分成多个工作单元，并且可以被其他更高优先级的任务中断的。而提交阶段则是不可中断的。&lt;/p&gt;
&lt;p&gt;在实现中，我们使用一个 &lt;code class=&quot;language-text&quot;&gt;wipRoot&lt;/code&gt; 指向的 fiber 树来追踪渲染工作的进度。&lt;/p&gt;
&lt;h3&gt;渲染阶段&lt;/h3&gt;
&lt;p&gt;根据 &lt;code class=&quot;language-text&quot;&gt;render&lt;/code&gt; 函数的参数中提供的的元素完成 fiber 树的构建。构建 fiber 树的工作分为很多个工作单元，每个工作单元都是由  &lt;code class=&quot;language-text&quot;&gt;performUnitOfWork&lt;/code&gt; 函数执行。render 函数主要的工作是设置第一个工作单元，之后工作循环会调用 &lt;code class=&quot;language-text&quot;&gt;performUnitOfWork&lt;/code&gt;，直到所有的工作单元完成。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;performUnitOfWork&lt;/code&gt; 函数做三件事。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;为每个 fiber 创建对应的 DOM，并将创建的 DOM 节点的引用保存在该 fiber 中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为元素的所有子元素创建 fiber。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择下一个要执行的工作单元。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;performUnitOfWork&lt;/code&gt; 确定下一个工作单元的规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果当前 fiber 有 &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 则选择 &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则如果当前 fiber 有 &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt;，则选择 &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则如果当前 fiber 的 &lt;code class=&quot;language-text&quot;&gt;parent&lt;/code&gt; 有 &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt;，则选择 &lt;code class=&quot;language-text&quot;&gt;parent.sibling&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则继续向上寻找存在的 &lt;code class=&quot;language-text&quot;&gt;parent.sibling&lt;/code&gt;，直到抵达 root。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mJKlDU-vvMps2OdoWf_CcL7F49teQDXllZM8R7nLaUf1GwyK4Ll-egrcJdt0iwr16CaiV383e3HIax1Y3joiZBBt4FeOJNRFFBxsMyX1NuEBUnrZlTuOhz_RKxS9hTJQSjIhlpXNIRh2EpX-HSqCe_RNfbbuNG1hJp-VgAB7XJ4FMQMkgNp2C_s5vyqZ-7eaU?width=274&amp;#x26;height=318&amp;#x26;cropmode=none&quot; alt=&quot;Fiber Tree&quot;&gt;&lt;/p&gt;
&lt;h3&gt;提交阶段&lt;/h3&gt;
&lt;p&gt;一旦完成了所有的 render 工作（并非下一个工作单元），我们将整个 fiber 树提交到 DOM 中。&lt;/p&gt;
&lt;p&gt;递归地添加所有 fiber 的 DOM 节点到 DOM 树中。&lt;/p&gt;
&lt;h2&gt;协调（Reconciliation）&lt;/h2&gt;
&lt;p&gt;到目前为止，我们只是添加了元素到 DOM 中，但是还没有涉及更新或者删除节点。&lt;/p&gt;
&lt;p&gt;对于更新和删除，我们需要将从 &lt;code class=&quot;language-text&quot;&gt;render&lt;/code&gt; 函数中收到的元素构建新的的 fiber 树，并和提交到 DOM 的最后一个 fiber 树做比较。&lt;/p&gt;
&lt;p&gt;因此，我们需要在完成提交后保存对“我们提交给 DOM 的最后一个 fiber 树”的引用。我们称之为 &lt;code class=&quot;language-text&quot;&gt;currentRoot&lt;/code&gt;。&lt;code class=&quot;language-text&quot;&gt;currentRoot&lt;/code&gt; 的作用是用来和下一个版本的 fiber 树作比较，以得出从上一个版本的 fiber 树更新到下一个版本的 fiber 树所需的操作。&lt;/p&gt;
&lt;p&gt;我们还为每个 fiber 添加了 &lt;code class=&quot;language-text&quot;&gt;alternate &lt;/code&gt; 属性。这个属性是一个指向旧 fiber 的链接，也就是我们在上一个提交阶段提交到 DOM 所用的 fiber，这个属性的作用是为了方便比较相应的 fiber 节点，以及尽可能复用已有的对象。&lt;/p&gt;
&lt;p&gt;在上文我们提到过，在执行每个工作单元时，也就是 &lt;code class=&quot;language-text&quot;&gt;processUnitOfWork&lt;/code&gt; 函数执行时，我们要为当前处理的 fiber 的每个子元素创建 fiber。但是对于一次更新，没必要再为每个元素都创建一个新的 fiber，因为我们可能已经通过 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt; 保留了上次渲染所创建的 fiber，我们称之为 &lt;code class=&quot;language-text&quot;&gt;oldFiber&lt;/code&gt;。我们需要比较 &lt;code class=&quot;language-text&quot;&gt;oldFiber&lt;/code&gt; 和新的元素所对应的 fiber 是否相同。&lt;/p&gt;
&lt;p&gt;这里的判断是否相同需要检测三个条件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;oldFiber 是否不为 null。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;element 是否不为 null。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;oldFiber.type 是否等于 element.type。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只有这三个条件的判断结果全都为 true，才能确定新旧两个 fiber 是否相同。（这里所说的相同并不是严格意义上的相等，只是用于判断从上一个版本的 fiber 变成下一个版本的 fiber 所需要做的操作）。&lt;/p&gt;
&lt;p&gt;如果相同，则可以直接保留 DOM 节点，只需更新 props 即可。&lt;/p&gt;
&lt;p&gt;如果不相同但是 &lt;code class=&quot;language-text&quot;&gt;element&lt;/code&gt; 存在，要么这个位置之前没有 fiber，要么就是之前的fiber 和当前元素对应的 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 不相同，已经无法复用之前的了。这些情况都需要创建一个新的 fiber。&lt;/p&gt;
&lt;p&gt;如果不相同但是 &lt;code class=&quot;language-text&quot;&gt;oldFiber&lt;/code&gt; 存在，要么这个位置之前的 fiber 在当前版本被移除了，要么就是之前的 fiber 和当前元素对应的 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 不相同，已经无法复用之前的了，对于第一种情况我们需要删除之前的旧 fiber，对于第二种情况，我们需要将之前的旧 fiber 删除，然后替换成新的元素创建的 fiber。&lt;/p&gt;
&lt;p&gt;这里 React 也使用了 key，这可以更好地协调。例如，它检测子元素何时更改元素数组中的位置。&lt;/p&gt;
&lt;p&gt;在对比时会添加的 &lt;code class=&quot;language-text&quot;&gt;effectTag&lt;/code&gt;，再后续的提交阶段会用到，用于标记需要对这些 fiber 做的操作。&lt;/p&gt;
&lt;p&gt;因为新的 workInProcess 树中，不会有被删除的节点，但是这些节点需要在提交到 DOM 阶段被删除，所以需要追踪这些要删除的 fiber 节点。&lt;/p&gt;
&lt;p&gt;在提交阶段我们根据提交的每个 fiber 节点标签，对 DOM 采取新增，更新，或则删除操作。在执行跟新操作时，我们需要为 DOM 节点添加新的属性，并且移除已经不存在的属性。除此之外，我们还需要处理事件监听器的订阅和取消。&lt;/p&gt;
&lt;h2&gt;函数组件&lt;/h2&gt;
&lt;p&gt;函数组件是一个返回元素的函数，是对特定元素结构和属性的封装。前面提到的都是将元素渲染到宿主（在浏览器中是 DOM），函数组件和普通的元素不同，普通的元素的 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 属性是一个代表 HTML 标签名的字符串，和宿主组件有着一一对应的关系，而函数组件的 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 属性则是一个函数，并没有一个宿主组件与之对应，而且该组件也不需要出现在 DOM 树中。除此之外，函数组件依然有与之对应的 fiber，并且也参与协调。 它只是用于 react 的一个内部表示。所以我们可以得出函数组件的两个特点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数组件的 fibe 没有实际的 DOM 节点，它只是返回元素。&lt;/li&gt;
&lt;li&gt;通过执行函数来得到 &lt;code class=&quot;language-text&quot;&gt;children&lt;/code&gt;  来自而不是直接从 &lt;code class=&quot;language-text&quot;&gt;props&lt;/code&gt;中获取。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在提交阶段需要操作 DOM，而函数组件的 fiber 并没有对应的 DOM，所以在对函数组件对应的 fiber 执行提交的过程中，如果需要操作 DOM ，我们要在 working in process fiber 树中，从该函数组件对应的 fiber 开始，向上或向下查找到最近的一个有 DOM 的 fiber 节点，对于添加操作则是向上查找最近的父 DOM，将该 fiber 对应的 DOM 节点添加为父 DOM 的子节点，而对于删除操作则是向下查找最近的子 DOM，并把它在 DOM 树中移除。&lt;/p&gt;
&lt;h2&gt;Hooks&lt;/h2&gt;
&lt;p&gt;我们还要为函数组件增加 useState hook 的功能，让函数组件能够持有可变的状态。&lt;/p&gt;
&lt;p&gt;在 react 中，在函数组件中调用 useState 函数可以得到一个状态的最新值和修改该状态的方法。在上一节函数组件实现中，我们直到在更新函数组件对于的 fiber 时，我们会调用该 fiber 的 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 方法，也就是该函数组件对应的函数，函数组件不仅可以返回元素，还可以在函数中调用 hook。为了可以在同一个函数组件中调用多次  useState 来保存不同的状态，我们需要在该 fiber 中添加一个属性名 &lt;code class=&quot;language-text&quot;&gt;hooks&lt;/code&gt; 的数组。数组中的每个元素都是一个 useState hook，我们用 &lt;code class=&quot;language-text&quot;&gt;hookIndex&lt;/code&gt; 每次调用 useState 完成之前，我们会将下标加一，这样下一个 &lt;code class=&quot;language-text&quot;&gt;useState&lt;/code&gt; 的调用就是指向 &lt;code class=&quot;language-text&quot;&gt;fiber.hooks&lt;/code&gt; 中的下一个 hook 了。在 &lt;code class=&quot;language-text&quot;&gt;useState&lt;/code&gt; 函数中，我们会从当前 fiber 节点的备份 fiber 节点中获取上一次的 hook，也就是 &lt;code class=&quot;language-text&quot;&gt;fiber.alternate.hooks[hookIndex]&lt;/code&gt; ，这样来保证组件的状态得以保持。除此之外我们的每个 hook 中需要一个队列来保存对该 hook 的状态的修改动作，每次调用 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt; 时，我们会将一个新的函数添加到这个队列中，并且在调用 &lt;code class=&quot;language-text&quot;&gt;useState&lt;/code&gt; 时依次执行队列中的函数，并修改 hook 的状态。&lt;/p&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;我们把当前我们实现这个 React 叫做 Didact，我们没有包括很多 React 的功能和优化。例如，这些是 React 做得不同的几件事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Didact中，我们在渲染阶段是在行走整个树。而 React 则遵循一些提示和启发式方法，跳过没有变化的整个子树。&lt;/li&gt;
&lt;li&gt;在提交阶段，我们也在遍历整棵树。而 React 保留了一个链表，其中只有那些有影响的 fiber，并且只访问这些 fiber。
每次我们建立一个新的工作进展树时，我们为每个纤维创建新的对象。React会回收以前树上的纤维。&lt;/li&gt;
&lt;li&gt;当 Didact 在渲染阶段收到一个新的更新时，它会扔掉工作进度树并从根部重新开始。React 给每个更新打上一个到期时间戳，并用它来决定哪个更新的优先级更高。&lt;/li&gt;
&lt;li&gt;react 在协调时用到了 key 以优化效率。而 Didact 没有。&lt;/li&gt;
&lt;li&gt;还有更多…&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;源代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/uwpdver/myReact&quot;&gt;我根据文章的指导的写的实现代码 | (github)&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pomb.us/build-your-own-react/&quot;&gt;Build your own React&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[JavaScript面向对象——继承]]></title><description><![CDATA[继承 ECMAScript…]]></description><link>https://blog-ak8.pages.dev/JavaScript面向对象——继承/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/JavaScript面向对象——继承/</guid><pubDate>Sun, 07 Nov 2021 00:45:00 GMT</pubDate><content:encoded>&lt;h2&gt;继承&lt;/h2&gt;
&lt;p&gt;ECMAScript 继承实现继承主要是依赖原型链来实现的。&lt;/p&gt;
&lt;h3&gt;基本思想&lt;/h3&gt;
&lt;p&gt;利用原型让一个引用类型继承另一个引用类型的&lt;strong&gt;属性&lt;/strong&gt;和&lt;strong&gt;方法&lt;/strong&gt;。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如果让&lt;strong&gt;原型对象等于另一个类型的实例&lt;/strong&gt;，此时的原型对象将包含一个指向另一个原型的指针，相对应地，另一个原型中也包含着指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上诉关系依然成立，如此层层递进，就构成了&lt;strong&gt;实例&lt;/strong&gt;与&lt;strong&gt;原型&lt;/strong&gt;的链条。这就是所谓原型链的基本概念。&lt;/p&gt;
&lt;h3&gt;原型链的基本模式&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;property &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;getSuperValue&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;property&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;subproperty &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 继承了 SuperType&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;getSubValue&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;subproperty&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; instance &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;instance&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getSuperValue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;SubType&lt;/code&gt; 将原型替换成了 &lt;code class=&quot;language-text&quot;&gt;SuperType&lt;/code&gt; 的实例，原先存在于 SuperType 的实例中的所有属性和方法，现在也存在于 &lt;code class=&quot;language-text&quot;&gt;SubType.prototype&lt;/code&gt; 中了。&lt;/p&gt;
&lt;h3&gt;默认原型&lt;/h3&gt;
&lt;p&gt;所有引用类型默认都继承于 Object 类，这个继承也是通过原型链实现的。所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。&lt;/p&gt;
&lt;h3&gt;确认原型与实例的关系&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;instanceof 运算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;isPrototypeOf() 方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;需要注意&lt;/h3&gt;
&lt;p&gt;给原型添加方法的代码一定要放在替换原型的语句之后，不然替换原型后创建的实例无法访问到添加的方法。因为方法被添加到了替换之前的原型对象中，而实例的内部指针指向了一个新的原型对象。&lt;/p&gt;
&lt;p&gt;在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这样做就会重写原型链。&lt;/p&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原型链上的所有属性都会被同类型的实例所共享。所以一个实例对原型链上的属性做的修改会反映到所有该类型实例上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有办法在不影响其他实例的情况，向超类构造函数传递参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;借用构造函数&lt;/h3&gt;
&lt;p&gt;在子类中调用超类的构造函数，这样在超类的实例中添加的属性的操作也会在子类创建实例时在子类实例上执行。这样子类就拥有了超类的属性和方法。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;colors &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;red&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;blue&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;green&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; instance1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
instance1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;colors&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;black&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;instance1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;colors&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;red,blue,green,black&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; instance2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;instance1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;colors&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;red,blue,green&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这种方式创建的实例，属性都在对象实例中，不同的实例的属性互不影响。&lt;/p&gt;
&lt;h4&gt;向父组件的构造函数传递参数&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;jojo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; instance &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;instance&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;jojo&quot;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;instance&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 17&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无法复用函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无法继承到超类的原型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;组合继承&lt;/h3&gt;
&lt;p&gt;组合原型链模式和构造函数模式，利用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承，既可以继承原型链，保证共享属性和函数复用，又能保证每个实例有自己的属性。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;sayName&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; stand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stand &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; stand&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Kakyoin&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;callStand&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;callStand&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;jojo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Star Platinum&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Polnareff&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;Kakyoin,Polnareff&quot;; &lt;/span&gt;
person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;jojo&quot;&lt;/span&gt;
person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;callStand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;Star Platinum&quot;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;dio&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;120&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;The World&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;Kakyoin&quot;; &lt;/span&gt;
person2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;dio&quot;&lt;/span&gt;
person2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;callStand&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;The World&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;原型式继承&lt;/h3&gt;
&lt;p&gt;不用写新的构造函数，通过已有的对象，构建新对象。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; baseObj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;jojo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  age&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function-variable function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token class-name&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; o&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;baseObj&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;dio&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;callFriends&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;frirends&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;jojo&quot;&lt;/span&gt;
person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;callFriends&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;dio&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;改进&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不用创建新的构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用原型对象的属性和方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以不影响其他对象的情况下，添加新的属性和方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;适用 &lt;code class=&quot;language-text&quot;&gt;instance&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;isPrototypeOf()&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Object.create()&lt;/h3&gt;
&lt;p&gt;第一个参数用作新对象原型，第二个参数用于定义额外的属性。第二个参数与 &lt;code class=&quot;language-text&quot;&gt;Object.defineProperties()&lt;/code&gt; 方法的第二个参数格式相同。&lt;/p&gt;
&lt;h3&gt;寄生式继承&lt;/h3&gt;
&lt;p&gt;就是把上面的原型模式的修改原型，创建对象，和添加实例属性封装在一个工厂函数中。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createAnother&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;original&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; clone &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;original&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  clone&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;stand &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Star Platinum&apos;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; clone&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;改进&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;将逻辑封装在了一起。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;无法复用函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;寄生组合式继承&lt;/h3&gt;
&lt;p&gt;使用组合式继承至少调用两次超类的构造函数，一次是创建超类的实例作为原型对象的时候，一次是调用本类的构造函数的时候。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;inheritPrototype&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;subType&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; superType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; prototype &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;superType&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;constructor &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; subType&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  subType&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; prototype&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;colors &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;red&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;blue&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;green&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;sayName&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;SuperType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;inheritPrototype&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;SubType&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; SuperType&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;sayAge&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; instance1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;jojo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
instance1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;colors&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;black&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;instance1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;colors&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;red,blue,green&quot;;&lt;/span&gt;
instance1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;jojo&quot;&lt;/span&gt;
instance1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayAge&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 17&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; instance2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SubType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;dio&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;120&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;instance1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;colors&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;red,blue&quot;;&lt;/span&gt;
instance1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &quot;dio&quot;&lt;/span&gt;
instance1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayAge&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 120&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;改进&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不必为了指定子类型的原型而调用超类型的构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定子类型原型的方式变成：通过超类的原型创建一个以该对象为原型的空实例，将该实例作为子类的原型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这样就不会调用两次超类的构造函数，子类的原型链与组合式保持不变，子类的原型中还没有了超类重复定义的多余的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集寄生继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[南风天]]></title><description><![CDATA[这两天是南风天，空气温和又湿润。感觉空气都是静止的，没有风。虽然现在是 11 月的秋天，站在外面完全不会感觉到寒意，室外像是刚刚好的温度和湿度。]]></description><link>https://blog-ak8.pages.dev/南风天/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/南风天/</guid><pubDate>Sat, 06 Nov 2021 00:17:00 GMT</pubDate><content:encoded>&lt;p&gt;这两天是南风天，空气温和又湿润。感觉空气都是静止的，没有风。虽然现在是 11 月的秋天，站在外面完全不会感觉到寒意，室外像是刚刚好的温度和湿度。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript面向对象——创建对象和原型]]></title><description><![CDATA[对象的属性 属性两种类型 数据属性 访问器属性 四个属性特征 ：可配置性，能否用 delete 删除，以及能否修改属性的特征值 ：可枚举型性，能否用 for in 枚举 ：可写性，能否修改该属性的值 ：保存属性的值，属性从这里读取，新的值替代这个位置的值 Object…]]></description><link>https://blog-ak8.pages.dev/JavaScript面向对象——创建对象/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/JavaScript面向对象——创建对象/</guid><pubDate>Fri, 05 Nov 2021 23:59:00 GMT</pubDate><content:encoded>&lt;h2&gt;对象的属性&lt;/h2&gt;
&lt;p&gt;属性两种类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据属性&lt;/li&gt;
&lt;li&gt;访问器属性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;四个属性特征&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;[[Configurable]]&lt;/code&gt;：可配置性，能否用 delete 删除，以及能否修改属性的特征值&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;[[Enumerable]]&lt;/code&gt;：可枚举型性，能否用 for in 枚举&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;[[Writable]]&lt;/code&gt;：可写性，能否修改该属性的值&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;[[Value]]&lt;/code&gt;：保存属性的值，属性从这里读取，新的值替代这个位置的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Object.defineProperty() 设置属性的特性&lt;/p&gt;
&lt;p&gt;访问器属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;[[Set]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;[[Get]]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Object.getOwnPropertyDescriptor() 获取属性的特性&lt;/p&gt;
&lt;h2&gt;创建对象的方式&lt;/h2&gt;
&lt;p&gt;方式 1——new Object&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; obj1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
obj1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;to&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
obj1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;be&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
obj1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;c &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;or&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;obj1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式 2——字面量&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; obj2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  a&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;to&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  b&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;be&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  c&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;or&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;obj2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建多个对象的方式&lt;/h2&gt;
&lt;h3&gt;工厂模式&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createPerson&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  obj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  obj&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; obj&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; jojo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;createPerson&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;jojo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;jojo&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过工厂函数，创建对象，为对象添加属性，然后返回对象。&lt;/p&gt;
&lt;h4&gt;改进&lt;/h4&gt;
&lt;p&gt;可以方便地创建多个有相同属性的对象。&lt;/p&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;无法辨识类型，方法无法复用，没有共享属性。&lt;/p&gt;
&lt;h3&gt;构造函数模式&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; agel
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;sayName&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; jojo &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;jojo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; dio &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;dio&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;120&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

jojo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &apos;jojo&apos;&lt;/span&gt;
dio&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &apos;dio&apos;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;jojo instance Person&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;dio instance Person&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建一个新对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行构造函数中的代码（为这个新对象添加属性）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回新对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;相同类的实例&lt;strong&gt;没有共享方法&lt;/strong&gt;，每个实例都会创建一个新的函数，即使所有的实例的函数的作用都是一样的。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;dio&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sayName &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; jojo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sayName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// false&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;解决方法&lt;/h4&gt;
&lt;p&gt;将方法提取到外部定义，构造函数内只将外部的函数赋值给 this 的属性。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; agel
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sayName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; sayName
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;定义在全局的方法只能由实例内部调用，不够内聚。&lt;/p&gt;
&lt;h3&gt;原型模式&lt;/h3&gt;
&lt;p&gt;我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以&lt;strong&gt;由特定类型的所有实例共享&lt;/strong&gt;的属性和方法。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;jojo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;dio&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Bob&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;sayName&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// jojo&lt;/span&gt;
person2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// jojo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;理解原型对象&lt;/h3&gt;
&lt;h4&gt;构造函数与其原型对象之间的联系&lt;/h4&gt;
&lt;p&gt;无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 &lt;code class=&quot;language-text&quot;&gt;prototype&lt;/code&gt; 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会都会自动获得一个 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt;（构造函数）属性，这个属性包含一个指向 &lt;code class=&quot;language-text&quot;&gt;prototype&lt;/code&gt; 属性所在函数的指针。就拿前面的例子来说，&lt;code class=&quot;language-text&quot;&gt;Person.prototype.constructor&lt;/code&gt; 指向 &lt;code class=&quot;language-text&quot;&gt;Person&lt;/code&gt;。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。&lt;/p&gt;
&lt;h4&gt;实例与构造函数的原型对象之间的的联系&lt;/h4&gt;
&lt;p&gt;当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性）&lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt;，指向构造函数的原型对象。这个连接存在于&lt;strong&gt;实例&lt;/strong&gt;与&lt;strong&gt;构造函数的原型对象&lt;/strong&gt;之间，而不是存在于实例与构造函数之间。&lt;/p&gt;
&lt;h4&gt;对象属性的查找过程&lt;/h4&gt;
&lt;p&gt;每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。&lt;/p&gt;
&lt;p&gt;由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。&lt;/p&gt;
&lt;p&gt;如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。&lt;/p&gt;
&lt;p&gt;不过，使用 &lt;code class=&quot;language-text&quot;&gt;delete&lt;/code&gt; 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。&lt;/p&gt;
&lt;p&gt;原型模式的问题：举例——共享的引用类型，对原型上的一个引用类型修改，会反应在所有实例上&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;jojo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// for in 可以遍历对象所有可枚举的属性，包括原型对象上的属性  &lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; key &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; person&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 控制台输出: &lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// name&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// age&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// hasOwnProperty 对存在于实例中的属性返回 true，否则返回 false&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; key &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; person&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hasOwnProperty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 控制台输出: &lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// name&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// Object.getOwnPropertyNames 可以获得所有的属性名，无论属性是否可枚举。&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getOwnPropertyNames&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 控制台输出：&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// [&apos;constructor&apos;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;介绍方法&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法名&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;isPrototypeOf&lt;/td&gt;
&lt;td&gt;检测原型是否是存在于某个实例中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hasOwnProperty&lt;/td&gt;
&lt;td&gt;检测一个属性是否为实例属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.getPrototypeOf&lt;/td&gt;
&lt;td&gt;获取一个对象的原型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.keys&lt;/td&gt;
&lt;td&gt;获取对象所有可枚举的的实例属性。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.getOwnPropertyNames&lt;/td&gt;
&lt;td&gt;获取当前对象的所有属 实例中的属性名，无论是否可枚举。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Object.getOwnPropertyDescriptor&lt;/td&gt;
&lt;td&gt;获取对象实例属性的描述符。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;通过对象字面量重写原型&lt;/h4&gt;
&lt;p&gt;通过对象字面量重写原型，会失去 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt;。把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;constructor&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// function Person(){}&lt;/span&gt;
person&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;jojo&apos;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;constructor&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// undefined&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;jojo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// jojo&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;dio&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  age&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;120&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// dio&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// jojo&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 120&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// undefined&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isPrototypeOf&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person1&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// false&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;组合构造模式和原型模式&lt;/h3&gt;
&lt;p&gt;构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;dio&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;sayName&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;jojo&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;dio&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;120&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;bob&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [&apos;dio&apos;, &apos;bob&apos;]&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [&apos;dio&apos;]&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; person2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;friends&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// false&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sayName &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; person2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sayName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// false&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;改进&lt;/h4&gt;
&lt;p&gt;每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用。&lt;/p&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;构造函数和原型分离，不够内聚。&lt;/p&gt;
&lt;h3&gt;动态原型模式&lt;/h3&gt;
&lt;p&gt;在构造函数中初始化原型。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//属性 &lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;//方法 &lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;sayName &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;function&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;sayName&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;寄生构造函数&lt;/h3&gt;
&lt;p&gt;类似工厂模式。寄生构造函数返回的对象与构造函数以及构造函数的原型对象之间没有关系，所以可以使用其他模式的情况下，不要使用寄生构造函数模式。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token parameter&quot;&gt;name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; age&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; o &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
  o&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  o&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  o&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;job &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; job&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  o&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function-variable function&quot;&gt;sayName&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;token function&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; o&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot; jojo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
person1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sayName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// jojo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;稳妥构造函数模式&lt;/h3&gt;
&lt;p&gt;不使用 new 和 this，在安全性要求高的时候用到。与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此 instanceof 操作符对这种对象也没有意义。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[对称的二叉树——二叉树，递归]]></title><description><![CDATA[题目： 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 但是下面这个 [1,2,2,null,3,null,…]]></description><link>https://blog-ak8.pages.dev/对称的二叉树——二叉树，递归/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/对称的二叉树——二叉树，递归/</guid><pubDate>Mon, 01 Nov 2021 12:06:00 GMT</pubDate><content:encoded>&lt;h2&gt;题目：&lt;/h2&gt;
&lt;p&gt;请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。&lt;/p&gt;
&lt;p&gt;例如，二叉树 [1,2,2,3,4,4,3] 是对称的。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;二叉树-1
    1
   / \
  2   2
 / \ / \
3  4 4  3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;二叉树-2
    1
   / \
  2   2
   \   \
   3    3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;示例：&lt;/h3&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：root = [1,2,2,3,4,4,3]
输出：true&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例二：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：root = [1,2,2,null,3,null,3]
输出：false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;限制:&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;0 &amp;lt;= 节点个数 &amp;lt;= 1000&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;h3&gt;&lt;del&gt;检测中序遍历后的序列&lt;/del&gt;&lt;/h3&gt;
&lt;p&gt;观察题目之后，第一个想到的思路是将二叉树中的数字按照中序遍历添加到一个数组中，由于中序遍历的特点，数组中间的元素是树的根节点，左侧是左子树生成的中序遍历数组，右边是右子树生成的中序遍历数组。一颗对称的树所生成的数组左右两侧是对称的，可以用类似检测回文的方式检测该数组，来达到检测对称二叉树的目的。&lt;/p&gt;
&lt;p&gt;例如，对于上文中的二叉树-1，中序遍历之后生成的数组为以下顺序。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体做法是：在数组的前后设置双指针，检测两个指针指向的数字是否相等，如果不相等则不是对称二叉树，直到两个指针重合。&lt;/p&gt;
&lt;p&gt;后来发现这种检测方式是不严谨的，一个明显的反例。有一棵二叉树如下所示：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;二叉树&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;
    &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;
   &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; \
  &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;   &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
   \   \
   &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;    &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;
 &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;    &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于二叉树-3，中序遍历之后生成的数组为以下顺序。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个数组是明显是左右对称的，但是生成它的二叉树也明显不是对称二叉树。这是因为不同的二叉树中序遍历的结果可能是相同的，而且有很多种情况。所以这个思路行不通。&lt;/p&gt;
&lt;h3&gt;递归检测左右子树&lt;/h3&gt;
&lt;p&gt;观察对称二叉树的结构，可以发现，对称的关键是&lt;strong&gt;根节点的左子树和右子树互为镜像&lt;/strong&gt;，而两个树互为镜像需要满足的条件是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;都为 null 的两棵树互为镜像。&lt;/li&gt;
&lt;li&gt;两棵树中只有一棵树为 null，则这两棵树不互为镜像。&lt;/li&gt;
&lt;li&gt;根节点的值相同&lt;/li&gt;
&lt;li&gt;A  树的左子树与 B 树的右子树互为镜像。&lt;/li&gt;
&lt;li&gt;A 树的右子树与 B 树的左子树互为镜像。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题拆分之后，有了递归的结构。这样可以把以上的规则对应到递归问题框架的每个步骤中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归终止：1，2。&lt;/li&gt;
&lt;li&gt;处理当前节点：3。&lt;/li&gt;
&lt;li&gt;缩减问题规模，解决子问题：4，5。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://www.processon.com/view/link/617f9003f346fb0ef3d51641&quot;&gt;图解&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;要点：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个递归函数要处理的是&lt;strong&gt;两个&lt;/strong&gt;树的根节点，而在一般的二叉树问题中，每个递归函数往往只用处理单个节点，虽然处理的节点数量不同，但是基本的原则是一致的：处理当前层级，拆分出当前问题的子问题，求解子问题，根据子问题的解计算出当前问题的解。&lt;/li&gt;
&lt;li&gt;谨慎处理递归退出条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;/**
 * @param {TreeNode} root
 * @return {boolean}
 */&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;isSymmetric&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; root&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;right&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;treeLeft&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; treeRight&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 处理递归终止条件&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;treeLeft &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;treeRight&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;treeLeft &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; treeRight&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 处理当前节点&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;treeLeft&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;val &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; treeRight&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;val&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 递归处理子节点&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;treeLeft&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; treeRight&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;right&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;treeLeft&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;right&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; treeRight&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/&quot;&gt;剑指 Offer 28. 对称的二叉树 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[gatsby-plugin-sharp 插件的故障排除记录]]></title><description><![CDATA[我又花费了大概 6 个小时去解决去解决 npm 的报错，我真的对 npm 深恶痛绝。 昨天我在装修我的博客，给博客的关于页面填充更多的信息，其中有一个展示技术栈的章节，我给每个技术的名字前面增加它们对应的图标。要搞清楚怎么用 Gatsby…]]></description><link>https://blog-ak8.pages.dev/gatsby-plugin-sharp 插件的故障排除记录/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/gatsby-plugin-sharp 插件的故障排除记录/</guid><pubDate>Sun, 31 Oct 2021 16:06:00 GMT</pubDate><content:encoded>&lt;p&gt;我又花费了大概 6 个小时去解决去解决 npm 的报错，我真的对 npm 深恶痛绝。&lt;/p&gt;
&lt;p&gt;昨天我在装修我的博客，给博客的关于页面填充更多的信息，其中有一个展示技术栈的章节，我给每个技术的名字前面增加它们对应的图标。要搞清楚怎么用 Gatsby 的方式使用图片也是一件很麻烦的事情，这里就不细说，总之我弄了一个白天，终于把关于页面做好了。&lt;/p&gt;
&lt;p&gt;提交代码等待 cloudflare page 自动部署成功。结果过了很久还没有更新好，上 cloudflare page 一看，构建过程出错了。错误信息是 &lt;code class=&quot;language-text&quot;&gt;Gatsby-plugin-sharp wasn&apos;t setup correctly in gatsby-config.js. Make sure you add it to the plugins array&lt;/code&gt;。字面意思就是 &lt;code class=&quot;language-text&quot;&gt;Gatsby-plugin-sharp&lt;/code&gt; 没有正确地设置在 &lt;code class=&quot;language-text&quot;&gt;gatsby-config.js&lt;/code&gt;文件中。我检查了一下发现是按照正确的方式设置的，在本地运行了构建脚本之后发现本地也有同样的问题。于是我开始用搜索寻找解决的办法，有的回答说是没有安装 &lt;code class=&quot;language-text&quot;&gt;Gatsby-plugin-sharp&lt;/code&gt; 这个包，但是我是安装了的。还有的回答说要清理 npm 的缓存。我也试过了，没用。中间尝试了各种方法，包括但不限于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;删除 node_module 目录，重新安装依赖，无法安装成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换 npm 源为淘宝源，使用 npm 重新安装依赖，依然无法安装成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 cnpm 安装依赖，结果找不到对应的版本的包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单独安装 &lt;code class=&quot;language-text&quot;&gt;gatsby-plugin-sharp&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;gatsby-plugin-sharp&lt;/code&gt; 版本更新了，但依然无法构建成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git 回滚到更新 &lt;code class=&quot;language-text&quot;&gt;gatsby-plugin-sharp&lt;/code&gt; 之前的版本，重新安装依赖，依然无法安装成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 yarn 安装依赖，在安装 sharp 这个包时结果提示找不到 python&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装了 python，又提示需要  visual stdio。&lt;/li&gt;
&lt;li&gt;安装了 visual stido，又提示缺少 C++ 核心组件，但是 C++ 核心组件体积太大了，而且之前也不需要安装这些东西也可以成功，于是没有在这条路上走下去。&lt;/li&gt;
&lt;li&gt;因为是安装 sharp 这个库出现的问题，于是单独安装 sharp，每次都失败，错误信息是 &lt;code class=&quot;language-text&quot;&gt;Something went wrong installing the &quot;sharp&quot; module&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;去 sharp 的官方文档中，看到了关于安装失败的建议，就是切换淘宝源，切换之后安装 sharp 成功了，但是 &lt;code class=&quot;language-text&quot;&gt;gatsby build&lt;/code&gt;还失败，并且是和上一步相同的错误信息。&lt;/li&gt;
&lt;li&gt;继续搜索安装 sharp 的错误，看到 &lt;code class=&quot;language-text&quot;&gt;gatsby-plugin-sharp&lt;/code&gt; 的&lt;a href=&quot;https://www.gatsbyjs.com/plugins/gatsby-plugin-sharp/#troubleshooting&quot;&gt;官方文档&lt;/a&gt;中的故障排除，发现有可能是依赖 sharp 的包版本与 &lt;code class=&quot;language-text&quot;&gt;Gatsby 4.x&lt;/code&gt; 版本不兼容，需要更新。通过 &lt;code class=&quot;language-text&quot;&gt;yarn why sharp&lt;/code&gt; 命令查看有哪些包依赖 sharp，然后逐个将这些包升级到最新版本，运行 &lt;code class=&quot;language-text&quot;&gt;gatsby build&lt;/code&gt; 命令验证。结果还是出现和之前一样的报错。&lt;/li&gt;
&lt;li&gt;执行 &lt;code class=&quot;language-text&quot;&gt;yarn why sharp&lt;/code&gt; 命令查看当前已安装的 sharp 的版本是否与依赖 sharp 的包所需的版本一致，检查之后发现差了 0.0.1 个版本号。又发现 sharp 被添加到了当前项目的依赖中，于是通过 &lt;code class=&quot;language-text&quot;&gt;yarn remove sharp&lt;/code&gt; 命令将当前的 sharp 移除。运行 &lt;code class=&quot;language-text&quot;&gt;gatsby build&lt;/code&gt; 命令验证。结果构建成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;结论&lt;/h3&gt;
&lt;p&gt;最终的原因就是&lt;strong&gt;当前安装的 gatsby 插件版本与当前安装的 gatsby 版本不兼容&lt;/strong&gt;，解决方案就是&lt;strong&gt;找到报错相关的插件，更新它们&lt;/strong&gt;。但是根据 npm 给出的报错信息，我根本找不到问题的原因，所以走了很多弯路。&lt;/p&gt;
&lt;p&gt;这次得到的教训就是：出了问题要思考自己在出错前做了什么改动。就像我昨天更新了一个很重要的包，它的插件没有更新，所以它们不兼容，导致了问题。而且要善用 git，每次小步改动，验证，提交。这样有助于从问题中恢复，以及定位问题。&lt;/p&gt;
&lt;p&gt;本来这次的踩坑记录是想写的非常规范化的，记录下每一个猜想，行动，结果，问题。按照顺序将这些内容填充。但是由于过了太久很多过程都忘记了，所以就做罢了。以后排查和解决问题的时候可以尝试用那种模式，一边记录一边排查。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[我的经历——从毕业到离开长沙]]></title><description><![CDATA[我是 2019 大学毕业的，快毕业时为了找工作自学了一点 Python…]]></description><link>https://blog-ak8.pages.dev/我的经历——从毕业到离开长沙/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/我的经历——从毕业到离开长沙/</guid><pubDate>Sat, 30 Oct 2021 14:22:00 GMT</pubDate><content:encoded>&lt;p&gt;我是 2019 大学毕业的，快毕业时为了找工作自学了一点 Python 就去找工作了，由于我简历也没什么拿得出手的东西，所有投了简历也没几家公司愿意搭理。那段时间我总共有两次面试经历，第一次大老远从株洲跑到广州面试一个游戏公司的运营岗位，面试完在广州玩了一天就回学校了。过了好一段时间给我发了 offer，但是因为薪资开得太低被我拒绝了。&lt;/p&gt;
&lt;p&gt;第二次面试是在长沙，一家很小很小的公司，当时我去面试的时候，整个公司大概只有十个工位。面试官就是公司的主管，他说我的毕业设计的课题和他博士论文的课题是一个方向的，刚好他问的一些专业的问题我都能答得上来，于是觉得我很不错。这件事情在之后每次开大会回忆往事的时候，他都会拿出来说。面试完了之后主管说我明天就可以来上班了，面对这么热情的态度，当时的我有点受宠若惊，而且薪资方面对于那时候的我已经很不错了，于是就定下来了。&lt;/p&gt;
&lt;p&gt;入职的时候应聘的岗位是软件工程师，对于初出茅庐的我来说，软件工程师是做什么的我也不太清楚，我只知道是写代码的。因为公司当时做的项目缺一个前端开发，于是就要刚入职的我做前端。我在大学时有接触到 HTML，CSS，JavaScript 等技术，但也是学习到一些皮毛。&lt;/p&gt;
&lt;p&gt;入职之后我学了一个星期的 react，就出差去了广州的总部驻场开发，我当时并不觉得驻场开发有什么不好，不用租房，每天有餐补而且上班还不用打卡，有这些我已经很满足了。到了广州看了几天文档就开始上手了，项目工期紧张，只能边学边做。那个项目是从 0 到 1 开发一个少儿编程的网站，这项任务也许对于经验丰富的前端来说很简单，但对于刚毕业没有任何经验的我来说做起来处处都会碰壁，所以为了跟上进度那两个月也加了不少班，有时下班回去之后还在写代码写到凌晨。现在回想起来，那是我一段很宝贵的经历，也是我快速成长的一段时间。在那期间我还受到了不少人的帮助，当时的后端开发和我很聊得来，他技术比我好也比我有经验，我们技术团队在广州的几个人都是由他负责，我请教了他不少问题，我们也总是一起吃饭和加班，我们之后成为了很好的朋友，离职之后还常有联系。还有当时的产品经历和 UI 设计师人也很好，都是很优秀的人。还有一个另外请的兼职外包前端，产品经理和 UI 设计对他都不怎么待见，但是我还是在他的代码里学到了不少的东西。我对他们表示由衷的感谢。&lt;/p&gt;
&lt;p&gt;开发完第一个版本之后我就回到了长沙，在这里租了房安置了下来。回来之后依然还是做之前的那个项目，那个网站还要持续地迭代和维护，按照老板的画的饼，他是想借助这个产品从教育行业进军互联网行业。随着项目规模一点一点做大，公司的人数从起初的 10几个人慢慢地增加到了 30 几个人，公司也搬去了一个更大的写字楼，我做的那个项目也迭代了一个又一个的版本，我的工作能力也受到了领导的认可，也给我加了几次薪水。可最终公司的业务并没有像老板画的饼一样迅速扩张起来。恰恰相反，2020 年爆发的新冠疫情和随后的 2021 年国家又开始出台对教育行业的限制政策令教育行业陷入寒冬，而公司的经营情况也是一片惨淡，员工的工资也是越发越晚。眼看着公司一点点地衰落，在为公司工作了两年多之后我终于离开了这家公司。不久后我离开了长沙，回了自己家。&lt;/p&gt;
&lt;p&gt;长沙是个不错的地方，我是湖南人，所以这里的食物符合我口味，这里的茶颜悦色不贵而且还挺好喝，还有很多小吃。长沙最不缺的就是那种打着童年味道噱头的饭店，但是在这里很多小巷里的老店也是生意兴隆。这里有各种网红店，虽然大部分网红店都不怎么样。一到节假日五一广场就是人山人海，到处都要排队。&lt;/p&gt;
&lt;p&gt;这里的演出活动很多，在大学期间我去长沙看过音乐节，看过五月天的演唱会。我喜欢听说唱音乐，长沙有一个很屌的说唱团体——C-Block，他们的歌我都很喜欢，他们的说唱增加了我对长沙的好感。在这里我还去看了我最喜欢的说唱歌手——法老的 Livehouse 专场，第一次在现实中这么近距离地看到一个明星，对这个人好像很熟悉，但是又很意外惊喜的感觉。我觉得那晚在 Livehouse 中发生的一切都很不真实。&lt;/p&gt;
&lt;p&gt;虽然也有城市的喧嚣，但长沙的人生活节奏不会太快。我的工作是双休，我有时周末会约朋友去打打篮球。这里的房价是所有省会城市中最便宜的，年轻人还是有希望能自己买房的。我租的房子在一个老旧的小区，那一片住了很多老人，那小区里有一个十字路口，开了几家夜宵店，晚上的时候有很多人在那里吃夜宵。十字路口还有一个小超市，夏天的时候，我晚上洗完澡经常会穿着拖鞋去那个超市买饮料，顺便在路上吹吹风，快到秋天的时候的风吹着特别惬意。&lt;/p&gt;
&lt;p&gt;这两年里，我没去爬过岳麓山，没去逛过河西的大学城，没有参观过任何一个博物馆，也没去看过湖南电视台。我只是在这里平平淡淡地度过了两年，但到了离开的时候还是很怀念。&lt;/p&gt;
&lt;p&gt;我的下一站打算去广州。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[折腾博客的一天]]></title><description><![CDATA[今天一整天都花在了折腾博客上。起因只是我想给我的博客加一个个人作品页面。实现的时候想到可能不止一个作品，应该是一个列表，所以最好是动态创建页面，创建页面的动态数据用 JSON 保存，后来看到了 Gatsby 可以直接导入 JSON 和 Yaml 文件，发现 yaml…]]></description><link>https://blog-ak8.pages.dev/折腾博客的一天/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/折腾博客的一天/</guid><pubDate>Sat, 30 Oct 2021 01:57:00 GMT</pubDate><content:encoded>&lt;p&gt;　　今天一整天都花在了折腾博客上。起因只是我想给我的博客加一个个人作品页面。实现的时候想到可能不止一个作品，应该是一个列表，所以最好是动态创建页面，创建页面的动态数据用 JSON 保存，后来看到了 Gatsby 可以直接导入 JSON 和 Yaml 文件，发现 yaml 语法更简洁，于是选择用 Yaml 作为数据源。然后又发现刚好有一个叫 gatsby-transformer-yaml 的 gatsby 插件可以将 Yaml 文件转化成可以用 graphQL 查询的对象，但是当我在安装这个插件的时候 npm 每次都报错 &lt;code class=&quot;language-text&quot;&gt;unable to resolve dependency tree.&lt;/code&gt;，重试了好几次，每次都安装失败。我去网上搜索安装失败的报错信息，看到一个删除 node_modules，清除 npm 缓存的方法，想试一下，结果 node_modules 因为 windows 的权限问题一直删不掉，错误提示是需要另一个用户的权限。就这样从一个错误到了另外一个错误。我干脆把博客的代码库重新克隆下来，重新安装一次依赖。结果这个新克隆的仓库还是有同样的问题，这让我很烦躁。&lt;/p&gt;
&lt;p&gt;我再仔细看了报错的信息，发现有可能是 nodejs 版本的问题，我又把 node 更新到了最新版，期间又出了错，但试了两次还是更新好了。随后又发觉有可能是 Gatsby 版本的问题，于是一狠心又把 Gatsby 从 3.x 的版本更新到了最新的 4.x 版本，看文档上说 4.x 相比 3.x 版本构建速度提升了 40%。我满心期待地升级完 Gatsby 之后，再把和新版不兼容的插件也更新到新版。发现好像是用一个 npm install 的选项参数 &lt;code class=&quot;language-text&quot;&gt;--legacy-peer-deps&lt;/code&gt; 可以正常安装。经过一番漫长的挣扎终于把 gatsby-transformer-yaml 这个插件安装上了。然后看教程学怎么用 graphQL  查询的数据动态创建页面。然后 createPage 怎么传递参数到模板，模板怎么用页面的参数查询数据。好不容易折腾出来了两个页面。&lt;/p&gt;
&lt;p&gt;已经可以通过文件系统中指定路径的 Yaml 文件动态创建页面了，接下来就是给页面添加上样式。添加样式的过程中发现给元素起一个合适的类名实在是太难了，于是又想起了老朋友 tailwindcss。索性又安装了 tailwindcss，安装的过程也不是很顺畅。然后既然要换用 tailwindcss 了，那么之前的很多样式就可以删除了，于是替换样式又花了我好几个小时。tailwindcss 会重设浏览器的默认样式，而我博文章的页面本来需要浏览器的默认样式，这样一来我还得一个个地给把那些样式给加回来，这太麻烦了，我去官方文档找有没有简便一点的方法，然后就发现了 @tailwindcss/typography 这个插件，它只用给一个标签加上一个特定的类名，就可以恢复该标签内所有被 tailwindcss 重设的默认样式，或者是添加另一套排版的样式。为了方便统一样式，我还把一些元素拆分成了组件，有的组件可能仅是封装了特定的样式的 HTML 标签，也许不是很有提炼成组件的必要。但是这样组件化之后，写起来还挺方便的，也不用一串类名重复复制好多遍。&lt;/p&gt;
&lt;p&gt;折腾到晚上，接下来要在产品页面做一个可以横向滚动的屏幕截图列表的两个导航按钮，分别负责将列表滚动到前一个屏幕截图的位置和后一个屏幕截图的位置。到了晚上脑子已经一团浆糊了，但是最终还是被我做出来了一个能用的。思路大概是点击向前/向后按钮的时候根据当前滚动的位置和滚动条的总长度的比例来计算当前是第几个元素，然后获取到当前元素的前/后一个元素，调用该元素的 &lt;code class=&quot;language-text&quot;&gt;scrollIntoView&lt;/code&gt; 方法。虽然说起来很简单，但是我想到这个方法可是不容易，从开始写到可以用的过程还出了好几次错误。&lt;/p&gt;
&lt;p&gt;最后新页面也完成了，升级的依赖看上去也没什么问题了，准备推代码部署了。结果不知道是什么原因只要一同步远端的代码就会报错，试了好几次，好不容易有一次成功了，把新的代码推到了 GitHub。结果在部署的时候又出问题了：cloundflare page 构建的时候出错。重试了几次还是一样。看到错误信息好像是 node 版本不兼容的问题。但是我也不知道怎么改变部署时用的 node 版本。经过多次搜索得知，cloundflare page 在部署时会有一些环境变量，可以通过 NODE VERSION 这些个环境变量来指定部署时使用特定的 node 版本。经过我一番努力终于部署成功了。&lt;/p&gt;
&lt;p&gt;今天一天不知道遇到了多少 bug，关于写代码的问题很少，大都是环境依赖的问题。环境问题真是让人头大。唯一值得欣慰的是新增的两个页面都还挺好看的，而且最终也都把问题解决了。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[旋转数组的最小数字]]></title><description><![CDATA[题目： 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组  为  的一个旋转，该数组的最小值为…]]></description><link>https://blog-ak8.pages.dev/旋转数组的最小数字/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/旋转数组的最小数字/</guid><pubDate>Thu, 28 Oct 2021 23:30:00 GMT</pubDate><content:encoded>&lt;h2&gt;题目：&lt;/h2&gt;
&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 &lt;code class=&quot;language-text&quot;&gt;[3,4,5,1,2]&lt;/code&gt; 为 &lt;code class=&quot;language-text&quot;&gt;[1,2,3,4,5]&lt;/code&gt; 的一个旋转，该数组的最小值为1。&lt;/p&gt;
&lt;h3&gt;示例：&lt;/h3&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：[3,4,5,1,2]
输出：1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例二：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：[2,2,2,0,1]
输出：0&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;首先要理解数组的旋转这个概念，我的理解是：将数组从一个位置分为两个子数组，将这两个子数组之间的先后顺序交换，子数组内部的顺序不变。题目中给出的条件是输入的是递增排序的数组的旋转。从题目中给出的例子也可以看到，较小的子数组被旋转到了后面。所以如果从前往后遍历输入的数组的话，当遍历到一个数字比它前面的一个数字小，根据旋转的定义，旋转之后的两个子数组内部也一定是递增的，所以可以说明和前面那个数字不属于同一个子数组。该数字还是该子数组的第一个数字，也就是该子数组中最小的数字。因为这个子数组位于整个数组的后半部，所以旋转前它就是位于前半部，所以这个数字就是旋转前的递增数组的第一个数字，也就是我们要找的最小的数字。&lt;/p&gt;
&lt;h3&gt;注意：&lt;/h3&gt;
&lt;p&gt;当遍历完了整个数组还没有一个任何一个比前一个数字小的数字时，可以理解为这个数组分了一个空子数组旋转，相当于没有旋转，所以最小值还是数组中第一个数字。&lt;/p&gt;
&lt;h3&gt;要点：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有序递增数组。&lt;/li&gt;
&lt;li&gt;子数组顺序不变。&lt;/li&gt;
&lt;li&gt;找出变化不符合规律的数字即为切分点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;minArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;numbers&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;numbers&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; numbers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; numbers&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;numbers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; numbers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; numbers&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; result&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/&quot;&gt;剑指 Offer 11. 旋转数组的最小数字 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[数组中重复的数字——哈希表，空间换时间]]></title><description><![CDATA[…]]></description><link>https://blog-ak8.pages.dev/数组中重复的数字——哈希表，空间换时间/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/数组中重复的数字——哈希表，空间换时间/</guid><pubDate>Thu, 28 Oct 2021 22:46:00 GMT</pubDate><content:encoded>&lt;h2&gt;题目：&lt;/h2&gt;
&lt;p&gt;在一个长度为 &lt;code class=&quot;language-text&quot;&gt;n&lt;/code&gt; 的数组 &lt;code class=&quot;language-text&quot;&gt;nums&lt;/code&gt; 里的所有数字都在 &lt;code class=&quot;language-text&quot;&gt;0～n-1&lt;/code&gt; 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。&lt;/p&gt;
&lt;h3&gt;示例：&lt;/h3&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;限制：&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;2 &amp;lt;= n &amp;lt;= 100000&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;这道题目只要做过类似的用哈希表的题目，就很容易想到思路，典型的空间换时间。遍历一遍数组，将每个遍历到的数字都记录在一个哈希表中。这个哈希表中的每一个键代表当前已经遍历过的一个数字，当遍历到一个哈希表中存在的数字时，就说明这个数字重复了，返回它。这种方法的空间复杂度是 O(2n)，而时间复杂度只有 O(n)。&lt;/p&gt;
&lt;p&gt;如果不用哈希表记录的话，对于每一个数字，都遍历一遍数组，查看是否有与之相等的数字。这样的时间复杂度是 O(n^2)，空间复杂度是 O(n)。明显使用空间换时间很划算。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;findRepeatNumber&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nums&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; map &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;nums&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; num &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nums&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;map&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;has&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;num&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; num
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          map&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;num&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/&quot;&gt;剑指 Offer 03. 数组中重复的数字 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[盛最多水的容器——数组，双指针]]></title><description><![CDATA[题目： 给你 n…]]></description><link>https://blog-ak8.pages.dev/盛水最多的容器——数组，双指针/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/盛水最多的容器——数组，双指针/</guid><pubDate>Wed, 27 Oct 2021 18:19:00 GMT</pubDate><content:encoded>&lt;h2&gt;题目：&lt;/h2&gt;
&lt;p&gt;给你 n 个非负整数 &lt;code class=&quot;language-text&quot;&gt;a1，a2，...，an&lt;/code&gt;，每个数代表坐标中的一个点 &lt;code class=&quot;language-text&quot;&gt;(i, ai)&lt;/code&gt; 。在坐标内画 &lt;code class=&quot;language-text&quot;&gt;n&lt;/code&gt; 条垂直线，垂直线 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 的两个端点分别为 &lt;code class=&quot;language-text&quot;&gt;(i, ai)&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;(i, 0)&lt;/code&gt; 。找出其中的两条线，使得它们与 &lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt; 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;说明：你不能倾斜容器。&lt;/p&gt;
&lt;h3&gt;示例：&lt;/h3&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mjATL5jmyLw396pgSID-Sg8pNlPWicjA30JuB_Zr6A-Md6VkWRoiRMT59T26u2xCAzYAJPJWEwHeazC8eYXHHZpO4NINaaBZjEzNzBBenVg0WnOdes0mxXMXnWX443EjccA5Pi7pYA7JHmUcmcNHhGRK9doxBY1S3W2adaqNAbJz68uhNvHVsscblZxNgnXQG?width=660&amp;#x26;height=316&amp;#x26;cropmode=none&quot; alt=&quot;示例一图片&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例二：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：height = [1,1]
输出：1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例三：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：height = [4,3,2,1,4]
输出：16&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例四：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：height = [1,2,1]
输出：2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;提示：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;n == height.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;2 &amp;lt;= n &amp;lt;= 105&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;0 &amp;lt;= height[i] &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;在做这道题的时候，我没想到用双指针的方法，而是用复杂度为 O(n^2) 的嵌套循环暴力破解的方法，结果提交之后跑测试用例超时了。当时的想要解决的问题是如何记住面积最大的两个高度值的位置。结果思路是错误的。&lt;/p&gt;
&lt;p&gt;这道题目的关键在于对面积公式的理解，两条高围成一个容器，能装的水的面积是由两条高之间的距离和那条最小高来决定的。假设左边的高度在数组中的下标为 &lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt;，右边的高度在数组中的下标为 &lt;code class=&quot;language-text&quot;&gt;y&lt;/code&gt;，那么能装水的面积就是：&lt;code class=&quot;language-text&quot;&gt;s = min(height[x], height[y]) * (y - x)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;将公式分为两个部分，一个是 &lt;code class=&quot;language-text&quot;&gt;min(height[x], height[y])&lt;/code&gt;，一个是 &lt;code class=&quot;language-text&quot;&gt;y - x&lt;/code&gt;。&lt;code class=&quot;language-text&quot;&gt;height&lt;/code&gt; 是题目中给定的数组，所以我们只要改变或者 &lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;y&lt;/code&gt; 就可以获得一个新的 &lt;code class=&quot;language-text&quot;&gt;s&lt;/code&gt;。我们将这个每次迭代得到一个新的 &lt;code class=&quot;language-text&quot;&gt;s&lt;/code&gt; 都会将其与当前的 &lt;code class=&quot;language-text&quot;&gt;s&lt;/code&gt; 对比，保留较大值。&lt;/p&gt;
&lt;p&gt;因为数组中的高度是随机的，所以无论每次移动哪个指针 &lt;code class=&quot;language-text&quot;&gt;min(height[x], height[y])&lt;/code&gt; 的值的变化都是不确定的，而 &lt;code class=&quot;language-text&quot;&gt;y - x&lt;/code&gt; 的变化是更好控制的，我们可以将&lt;strong&gt;两个指针初始化在数组的两端&lt;/strong&gt;，左指针只能向右移动，而右指针只能向左移动。这样就可以保证 &lt;code class=&quot;language-text&quot;&gt;y - x&lt;/code&gt; 是随着每次指针移动递减的。&lt;/p&gt;
&lt;p&gt;我们遍历的目的是得到一个最大的 &lt;code class=&quot;language-text&quot;&gt;s&lt;/code&gt;，因为 &lt;code class=&quot;language-text&quot;&gt;y - x&lt;/code&gt; 是每次指针移动都会减小的。那每次移动的结果都要保证 &lt;code class=&quot;language-text&quot;&gt;min(height[x], height[y])&lt;/code&gt; 是有可能大于当前的值的。由于 &lt;code class=&quot;language-text&quot;&gt;min&lt;/code&gt; 是计算最小值，&lt;strong&gt;所以改变更小的数字可能让 &lt;code class=&quot;language-text&quot;&gt;min(height[x], height[y])&lt;/code&gt;  的值变大，而改变当前更大的数字只会使其更小或者不变&lt;/strong&gt;，所以要&lt;strong&gt;移动指向更小数字的指针&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;从数组的两端设置双指针。&lt;/li&gt;
&lt;li&gt;每端的指针只能向另一端移动，每次只能移动一个位置。&lt;/li&gt;
&lt;li&gt;每移动一次指针，就会有一个新的可能的结果。&lt;/li&gt;
&lt;li&gt;只有每次移动指向更小的数字的指针，才有可能得到更大的结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;maxArea&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;height&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;max&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; left&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; right&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; height&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;left &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; right&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        max &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;max&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;right &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; left&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;height&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; height&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;right&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;height&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;left&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; height&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;right&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;    
            left &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; left &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            right &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; right &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; max&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot;&gt;11. 盛最多水的容器 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[合并两个有序链表——链表]]></title><description><![CDATA[…]]></description><link>https://blog-ak8.pages.dev/合并两个有序链表——链表/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/合并两个有序链表——链表/</guid><pubDate>Tue, 26 Oct 2021 21:34:00 GMT</pubDate><content:encoded>&lt;h2&gt;题目：&lt;/h2&gt;
&lt;p&gt;将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。&lt;/p&gt;
&lt;h3&gt;示例：&lt;/h3&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4m6LzKDyuHqeTLPt1Z5PA_EedFEM2qsUV5z5izHzn0pgrZkpFbxQmJ2bdL6ALAkH7TQ9wnbtnQOIJalVkPX7X1co92QDA-wBIR6w-LGjgYQqBLInuEWJ9M1zuQUHHAUKn9MTn10F2lVrYIJzxiLiRNELyEy4mWdq9a1cZRneFu5asRwpiQ6-97gTZek4bjJC-J?width=662&amp;#x26;height=302&amp;#x26;cropmode=none&quot; alt=&quot;示例一图片&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例二：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：l1 = [], l2 = []
输出：[]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例三：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：l1 = [], l2 = [0]
输出：[0]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;提示：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;两个链表的节点数目范围是 &lt;code class=&quot;language-text&quot;&gt;[0, 50]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;l1&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;l2&lt;/code&gt; 均按 &lt;strong&gt;非递减顺序&lt;/strong&gt; 排列&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;假设有一条没有串球的红绳子，还有两条串着标有数字的球的链，每条链上球的标号都是从小到大依次递增的，每次从这两条链中选择一个数字最小的球串在红绳子上，当所有的球都串到红绳子上时，这条红绳子上的所有球上标的数字就是有序的了。&lt;/p&gt;
&lt;p&gt;这个问题的关键就在于如何选择数字最小的球。这两条链中各自最小的球都在最前面，但是不能确定哪条链中最小的数字更小，所以就要比较两条链中数字最小的球哪一个更小，并将其接到绳子上，这样一个球的顺序就排好了。因为上一轮比较已经将数字最小的球接在了红绳子上，因此不能重复选择。所以需要选择这条链的下一个球，也就是数字第二小的球与另一条链上数字最小的球比较，再选出两者之间数字较小的球接在绳子上。依次类推，直到其中一条链上的所有球都被接在红绳子上了，这样这条链已经没有球可以比较了。&lt;/p&gt;
&lt;p&gt;此时有可能另外一条链中还有部分球没有串到红绳上，但是可以确定的是，这条绳上的所有球都应该比最后一个被串到红绳上的球的数字大。因为只有当前链中选择的球比另一条链中的小才会该表选择到下一个球，才会先走到末尾。所以接下来只用将没有走完的那条链拼接到红绳上就完成了。&lt;/p&gt;
&lt;p&gt;将上述的步骤用在链表上就可以概括为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化指向两条链中指向未添加到新链的最小节点的指针。&lt;/li&gt;
&lt;li&gt;比较当前两个链表中最小的节点。&lt;/li&gt;
&lt;li&gt;然后将较小的节点拼接到当前已排序链表的最后一个节点后面。&lt;/li&gt;
&lt;li&gt;然后再迭代值向较小的节点的指针和指向已排序链表的最后一个节点的指针，迭代的方式都是向后移动一个节点。&lt;/li&gt;
&lt;li&gt;重复上述两个步骤，直到两个链的指针中有一个指向 null。&lt;/li&gt;
&lt;li&gt;拼接未遍历完的节点。&lt;/li&gt;
&lt;li&gt;返回新链表的头节点指针  。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;步骤图解&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;初始状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mjvdbWSY68KCrefLyAHrHv2-gbnGTnyC-fn9IhGlYxMy9qusABzxkBVQq8wEryM-L3Frqej0I2FDEe3UJyLtktcy5USn6MN1iaQW6afVb2pXWc2XRkoIHPyxDoH7HDwID69BO5ybfG_ZUZj5hZJL3owOoij7UI-j7BaHB2LACeax_1rR06uyItdqUdrfiAyvl?width=660&amp;#x26;height=478&amp;#x26;cropmode=none&quot; alt=&quot;初始状态&quot; title=&quot;初始状态&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;对比 p1.val 与 p2.val，将两条链表中更小的节点拼接到新链表。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mpAyoyFwiLr6LIBhPQiJ3rrcPgSWPbRoWI1a7kwanR51Oi26Rsr0cDl3aq8TiiKLdBtEIEc96Nx9dnx8_PjMJIEZ1WC0hiJ8T7LhIPaOIktrK4BjGGrIVlILtFO43MlSKakuDQ5gfylS9c4Cdm0pIt9WP4H1ALV-F-IgVJMsKQKNUqbKwz28PN_Fb_ANfmOU1?width=660&amp;#x26;height=478&amp;#x26;cropmode=none&quot; alt=&quot;将两条链表中更小的节点拼接到新链表&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;指针迭代，newList，p2 指针均向后移动一个节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4m12zHTlpZr9K6u-WvI2c3KFgGkHcb0nvseIir0TXRMcH9aGi2h_9LOPD-iKlIjHDE2HB-hmjaHWtFiSzjeUrXZcQKpYYqC0TfH1T6uPji7qg8zBK0qtKSkCRKhovPib1WhwAhHCZqXnySvFl1PTJDozc7O-pqMBGikbSkJ6lxPVMuBGKp1mdS1jhat-mx1ZdU?width=660&amp;#x26;height=498&amp;#x26;cropmode=none&quot; alt=&quot;指针迭代&quot; title=&quot;指针迭代&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;重复步骤 2。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mWVwle5jMf_7WzzngaMZJOZWLy2YWzbYP5xSzkGBTcNXTerlJL0au-IwX9iTZFDmL1DlIlB3rQ3tEWhNPsCbSfQJ1--84yRvCYTC0pczoqCZWPno-Tnzk2DP1gvnx0NzuVNs_5oPi3wGmtf2Oq2HNJIvkJ4-HxMQV300ozWAdEGvBH0shABjbKvigzIBD6Lvg?width=660&amp;#x26;height=498&amp;#x26;cropmode=none&quot; alt=&quot;拼接第二个节点&quot; title=&quot;拼接第二个节点&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;重复步骤 3。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4msoIxLeX72kg--BtWBmxm6z1Y4pj6X2Vhf0dc9x2VTcvdRt-lOupmjT24H0PoGLRl9FLZDvutD9VrUyUEs9duNtnDanJMqZMKz0_CCsBOJSNWHfkLzrVOps-xiWxDvt5KOEq7bxTWXw3_q6GnaF9Y8H73ZYl4OlNb9FDvS2T01jRWL5yzFdXUrzdWNb0_xQXQ?width=660&amp;#x26;height=498&amp;#x26;cropmode=none&quot; alt=&quot;继续移动指针&quot; title=&quot;继续移动指针&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;重复步骤 2。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4msoIxLeX72kg--BtWBmxm6z1Y4pj6X2Vhf0dc9x2VTcvdRt-lOupmjT24H0PoGLRl9FLZDvutD9VrUyUEs9duNtnDanJMqZMKz0_CCsBOJSNWHfkLzrVOps-xiWxDvt5KOEq7bxTWXw3_q6GnaF9Y8H73ZYl4OlNb9FDvS2T01jRWL5yzFdXUrzdWNb0_xQXQ?width=660&amp;#x26;height=498&amp;#x26;cropmode=none&quot; alt=&quot;继续移动指针&quot; title=&quot;继续移动指针&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;重复步骤 2。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4msoIxLeX72kg--BtWBmxm6z1Y4pj6X2Vhf0dc9x2VTcvdRt-lOupmjT24H0PoGLRl9FLZDvutD9VrUyUEs9duNtnDanJMqZMKz0_CCsBOJSNWHfkLzrVOps-xiWxDvt5KOEq7bxTWXw3_q6GnaF9Y8H73ZYl4OlNb9FDvS2T01jRWL5yzFdXUrzdWNb0_xQXQ?width=660&amp;#x26;height=498&amp;#x26;cropmode=none&quot; alt=&quot;继续拼接&quot; title=&quot;继续拼接&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;重复步骤 3。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4m0leT614D9Sxs96pFlj22HmqEL5CmkBcajZngpaKaIDQthnt18J20hTihDSkNN0jD14l93obPlFOKD3SggN8NiwbhDb21EwNCyDUF6R3uxLiq9HvfbzeAPVWHOPICrZKz6yjoCwjcIAG7gkEWOHcjDl_mSi80GFPuDNn-YsudsffSqFKTQvFFBg-WSRftHoh0?width=660&amp;#x26;height=498&amp;#x26;cropmode=none&quot; alt=&quot;继续移动指针&quot; title=&quot;继续移动指针&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;重复步骤 2。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4m_1JVjzGbWvBeyj7wVjcK4d399ZXzIYg98rWrQsNZIKK0leTlcPUAGs13XWVWYAfbw-p0zdSHpNiTefj9VDXnQo6WFSrW438tCwft9LdfHbX-8zj-w9BKCLN2esdpdV0nWqP1-2lgtwIYtspxjBfa_1cTRpBVtuwmCGVzVzu4iLel01yMkSG2YHZRRyx0QJBf?width=660&amp;#x26;height=498&amp;#x26;cropmode=none&quot; alt=&quot;继续比较，拼接&quot; title=&quot;继续比较，拼接&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;重复步骤 3。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mtJsMQI9yhmF-tRY3aMpaKwkqOxgO55GRmAZ5PRZD8dD9xLnYDWtXaJtH7zcibvmuu5lHBj3OyklIkf5aR1zPEdaNx5KvIOU-HyKRTQalqp0eQX03XaThBrDTMh3w_HZjzAGJiheln0MO9S6dmJ_neFhe6S_NFvicozdzgD7ovBRDGaJ7V9J_TKbKJWY33CKt?width=660&amp;#x26;height=498&amp;#x26;cropmode=none&quot; alt=&quot;继续移动指针&quot; title=&quot;继续移动指针&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;11&quot;&gt;
&lt;li&gt;重复步骤 2。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mSqghN-ccfpkZ5ftJrXbuynW6Bx4guabWE3D2VPbuaWzlzSBbAhFxMR1LdQ_CC1WDvFi45EPMrw9NWRbDDPc26KfIndLlDnnKf-kuzsID7baMxG19Ei-tpWyxX_bC11G4VKPd1ZAwLciDAlkmYyqYSCrZL12DL6PpNhAkNTcAixL69ChuUzNgJBZB1oPhOoHP?width=660&amp;#x26;height=498&amp;#x26;cropmode=none&quot; alt=&quot;继续比较，拼接&quot; title=&quot;继续比较，拼接&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;12&quot;&gt;
&lt;li&gt;重复步骤 3。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mXsKmHgBu5xxlrX0WENBuOX45tX5SYI-bvKei9zGt8qMdZEzrZ69vrelpR1T0v4KCZgRIpI-Ep9SRu3zmeNMoU5ES650YCUZzKxTYGSSLicj-QOhHw8KITODs6re_F5dr3Z5_bYg-uRX7I-2v1uF47w5wFRbFw59yG2cDDNg1okHl8dJYSu5EtfEDiDYp8Z8Y?width=660&amp;#x26;height=498&amp;#x26;cropmode=none&quot; alt=&quot;继续移动指针&quot; title=&quot;继续移动指针&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;13&quot;&gt;
&lt;li&gt;到达链表末尾，退出循环，拼接未遍历完节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4m09thjBQSLMFh2AoPNHa23iP-iMdBkC5NDm_-Bh22zpYaQkxjPCReV3vdEgs5wLZvlK81uYHKKCOcIJZOmyEIFszf7-vV0jVBiYCjKeCRUgaqnwG0FDs2QQZSSx-eVGeZgr21tp1tYG4t5DCYoFODRZvzlZ4T_5j6pEeChd7fvJ9SLPSYhlOHlv3ViFDrrjFl?width=660&amp;#x26;height=498&amp;#x26;cropmode=none&quot; alt=&quot;拼接未遍历完节点&quot; title=&quot;拼接未遍历完节点&quot;&gt;&lt;/p&gt;
&lt;ol start=&quot;14&quot;&gt;
&lt;li&gt;返回 dummy 的下一个节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mkPwgUo5y2MNriWB6Tocas0EaH_BNEgyGkCbibg67_dcoT-yvI39pXJklUMNP5SkL--wCGIGqVAmMd1ennZPkSvO4ivA7T8mmSIyAvfjIFdf0frvy0sOuUr6Jqat4sv2iN5F86BlLUofBs-1GBI5KMhG4u7LBE3m5QFj3jWRiQlhgQx8GhoFBgmMLRTMq7EaM?width=660&amp;#x26;height=486&amp;#x26;cropmode=none&quot; alt=&quot;返回 dummy 的下一个节点&quot; title=&quot;返回 dummy 的下一个节点&quot;&gt;&lt;/p&gt;
&lt;h3&gt;递归解法&lt;/h3&gt;
&lt;p&gt;这道题还有递归的解法，其实思路都一是相同的，只是缩减问题规模的方式不同。迭代方式的重复操作是放在循环里，而递归方式的重复操作则是放在函数中，每次递归的函数调用都相当于执行依次迭代方式中的循环体中的代码。递归方式的变量迭代通过&lt;strong&gt;参数传递&lt;/strong&gt;和函数的&lt;strong&gt;返回值&lt;/strong&gt;实现，而迭代方式则是直接为局部变量赋值。递归方式需要对不同的分支传递不同的参数，副作用和返回值也不同。细节直接看代码实现就能理解了。&lt;/p&gt;
&lt;h2&gt;注意&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;其中一条链表遍历完之后就应该停止循环。&lt;/li&gt;
&lt;li&gt;将没有遍历完的链表从当前的节点开始拼接到新链表。&lt;/li&gt;
&lt;li&gt;使用 dummy 节点让所有的节点以相同的方式处理，而不用对首节点特殊处理。&lt;/li&gt;
&lt;li&gt;熟练链表的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;迭代解法&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mergeTwoLists&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;l1&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; l2&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; dummyNode &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ListNode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;p1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; p2&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; newList&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;l1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; l2&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; dummyNode&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p1 &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; p2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        newList&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; p1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;val &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; p2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;val &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; p1 &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; p2&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 比较，拼接&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;val &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; p2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;val&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p1 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; p1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p2 &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; p2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 指针迭代&lt;/span&gt;
        newList &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; newList&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 指针迭代&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    newList&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; p1 &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; p2&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; dummyNode&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;递归解法&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mergeTwoLists&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;l1&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; l2&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;l1 &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; l2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;l1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;val &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; l2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;val&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          l1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mergeTwoLists&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;l1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; l2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; l1&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          l2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mergeTwoLists&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;l1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; l2&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; l2&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; l1 &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; l2 &lt;span class=&quot;token comment&quot;&gt;// 到达一条链的末尾，返回另一条链中的当前遍历到的节点&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot;&gt;206. 反转链表 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[浏览器工作原理——调用栈]]></title><description><![CDATA[总结 了解调用栈可以更好地理解 JavaScript 代码是按照什么顺序被执行的。调用栈是用来 JavaScript…]]></description><link>https://blog-ak8.pages.dev/浏览器工作原理——调用栈/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/浏览器工作原理——调用栈/</guid><pubDate>Mon, 25 Oct 2021 22:41:00 GMT</pubDate><content:encoded>&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;了解调用栈可以更好地理解 JavaScript 代码是按照什么顺序被执行的。调用栈是用来 JavaScript 解释器用来&lt;strong&gt;追踪函数执行流&lt;/strong&gt;的一种机制，通过这种机制，可以追踪到哪个函数正在执行（栈顶），执行的函数体中又调用了哪个函数（创建新的栈帧并压入调用栈），函数在调用栈中表示为执行上下文。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每调用一个函数，解释器就会把该函数（执行上下文）添加进调用栈并开始执行。&lt;/li&gt;
&lt;li&gt;正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。&lt;/li&gt;
&lt;li&gt;当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。&lt;/li&gt;
&lt;li&gt;当分配的调用栈空间被占满时，会引发“堆栈溢出”错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;执行上下文&lt;/h2&gt;
&lt;p&gt;有关正在运行的函数的执行过程的相关信息被保存在它的执行上下文中。&lt;a href=&quot;https://tc39.github.io/ecma262/#sec-execution-contexts&quot;&gt;执行上下文&lt;/a&gt; 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt; 的值（此处我们不使用它），以及其它的一些内部细节。&lt;/p&gt;
&lt;p&gt;一个函数调用仅具有一个与其相关联的执行上下文。&lt;/p&gt;
&lt;p&gt;当一个函数进行嵌套调用时，将发生以下的事儿：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前函数被暂停；&lt;/li&gt;
&lt;li&gt;与它关联的执行上下文被一个叫做 &lt;strong&gt;执行上下文堆栈&lt;/strong&gt; 的特殊数据结构保存；&lt;/li&gt;
&lt;li&gt;执行嵌套调用；&lt;/li&gt;
&lt;li&gt;嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack&quot;&gt;Call stack（调用栈） - 术语表 | MDN (mozilla.org)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.javascript.info/recursion&quot;&gt;递归和堆栈 (javascript.info)&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[反转链表——递归，链表]]></title><description><![CDATA[题目： 给你单链表的头节点  ，请你反转链表，并返回反转后的链表。 示例： 示例一： 示例一图片 示例二： 示例二图片 示例三： 提示： 链表中节点的数目范围是 [0, 5000] -5000 <= Node.val <= 500…]]></description><link>https://blog-ak8.pages.dev/反转链表——递归，链表/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/反转链表——递归，链表/</guid><pubDate>Sun, 24 Oct 2021 22:45:00 GMT</pubDate><content:encoded>&lt;h2&gt;题目：&lt;/h2&gt;
&lt;p&gt;给你单链表的头节点 &lt;code class=&quot;language-text&quot;&gt;head&lt;/code&gt; ，请你反转链表，并返回反转后的链表。&lt;/p&gt;
&lt;h3&gt;示例：&lt;/h3&gt;
&lt;p&gt;示例一：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mKX4kXheMf85DBRQMRmE2TTtt-ILOP_17kH_k4Pe-mVQF6tY55-LR8ADzMI5tO37cWlybtee2osjjjT0L15iKSLJJhKjlv429giAQBAyDNlU-3yZJg3Wd8bCwHa1bUn06IMk_FhUeH0u2Y8IZtKtVUVZyitbzZVqcx4xhMScvjBC0fDH1hvQvr3kYSPBX7mD7?width=542&amp;#x26;height=222&amp;#x26;cropmode=none&quot; alt=&quot;示例一图片&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例二：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mfLrTOAFTCFJvS72c8dwEs052DxT7UkUuIAJxXEFsCoFchG3e8Gq8TlChxvyuxyQYuUWy4NBZ0VPViEb2v988MWJwG9qfqXi8TL-3KJ4IuE3AwGRwqQX5SWSi2s45Ahupog_x7MjkIZIhc8wQLex-_SrXVUMtfM3i9AbFfXz4oP0NW4vIJCYC-DXnUBTuUN3m?width=182&amp;#x26;height=222&amp;#x26;cropmode=none&quot; alt=&quot;示例二图片&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：head = [1,2]
输出：[2,1]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例三：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：head = []
输出：[]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;提示：&lt;/h3&gt;
&lt;p&gt;链表中节点的数目范围是 [0, 5000]&lt;/p&gt;
&lt;p&gt;-5000 &amp;#x3C;= Node.val &amp;#x3C;= 5000&lt;/p&gt;
&lt;h3&gt;进阶：&lt;/h3&gt;
&lt;p&gt;链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;这道题的关键就是如何处理节点的 next 指针。&lt;/p&gt;
&lt;p&gt;该问题是一个关于链表问题，先要将完整的问题拆分成子问题，自然想到以链表的节点作为子问题的单元。我们聚焦到链表中的单个节点，发现只要将每个节点的 next 指针指向前一个节点就可以实现链表的反转了。所以处理每一个节点时，需要用到该节点的&lt;strong&gt;前一个节点&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;迭代实现&lt;/h3&gt;
&lt;p&gt;迭代的思路比较常规，保存两个指针，一个 &lt;code class=&quot;language-text&quot;&gt;cur&lt;/code&gt; 指针指向当前遍历的节点，一个 &lt;code class=&quot;language-text&quot;&gt;prev&lt;/code&gt; 指针指向当前遍历的节点的前一个节点，对链表遍历一遍，将每个节点的 next 指针指向 &lt;code class=&quot;language-text&quot;&gt;prev&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;递归实现&lt;/h3&gt;
&lt;p&gt;递归的思路通常不会第一时间被想到，注意这个方法存在调用栈超过最大限制的风险。思路就是利用函数调用栈先进后出的结构特点，函数调用时栈帧压入栈的顺序，与函数返回时栈帧弹出栈的顺序正好相反。所以如果按照原来的顺序对每个节点依次调用递归函数，那么在函数的返回阶段，相当于按照相反的顺序访问链表，这样每个函数中，递归调用的返回值就正好是当前节点的上一个节点。这样相当于隐式保存了当前节点和上一个节点，但是这样在调用时会在调用栈保存链表中的所有节点，所以内存占用会比较大。&lt;/p&gt;
&lt;h2&gt;注意&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;递归实现中，注意要保存递归调用阶段的最后一个节点，这个节点是反转后的链表的首节点，也是该问题的返回值。&lt;/li&gt;
&lt;li&gt;反转前的第一个节点，反转过后，这个节点就变成了最后一个节点，所以需要将这个节点的 next 赋值为 null，否则链表遍历一轮之后链表中会出现环，导致无法跳出循环或者递归过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;p&gt;公共部分&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/**
 * Definition for singly-linked list.
 * class ListNode {
 *     val: number
 *     next: ListNode | null
 *     constructor(val?: number, next?: ListNode | null) {
 *         this.val = (val===undefined ? 0 : val)
 *         this.next = (next===undefined ? null : next)
 *     }
 * }
 */&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;迭代实现&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reverseList&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;head&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;head &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; head&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; head&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;prev&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cur&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;head&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; head&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    head&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cur&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; cur&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        cur&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; prev&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        prev &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; cur&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        cur &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; next&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; prev&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归实现&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reverseList&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;head&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;head&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; head&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; newHead &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; head&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reverseListCore&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;head&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; ListNode &lt;span class=&quot;token operator&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;head&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; reversedListTail &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;reverseListCore&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;head&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            reversedListTail&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; head&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            newHead &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; head&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 保存最后一个节点作为反转后链表的第一个节点&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; 
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; head&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;token function&quot;&gt;reverseListCore&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;head&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    head&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;next &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 防止出现环&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; newHead&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot;&gt;206. 反转链表 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[两数和——哈希表]]></title><description><![CDATA[题目： 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target…]]></description><link>https://blog-ak8.pages.dev/两数和——哈希表/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/两数和——哈希表/</guid><pubDate>Sat, 23 Oct 2021 22:32:00 GMT</pubDate><content:encoded>&lt;h2&gt;题目：&lt;/h2&gt;
&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;h3&gt;示例：&lt;/h3&gt;
&lt;p&gt;示例一：&lt;br&gt;
输入：nums = [2,7,11,15], target = 9&lt;br&gt;
输出：[0,1]&lt;br&gt;
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。&lt;/p&gt;
&lt;p&gt;示例二：&lt;br&gt;
输入：nums = [3,2,4], target = 6&lt;br&gt;
输出：[1,2]&lt;/p&gt;
&lt;p&gt;示例三：
输入：nums = [3,3], target = 6&lt;br&gt;
输出：[0,1]&lt;/p&gt;
&lt;h3&gt;提示：&lt;/h3&gt;
&lt;p&gt;2 &amp;#x3C;= nums.length &amp;#x3C;= 104&lt;br&gt;
-109 &amp;#x3C;= nums[i] &amp;#x3C;= 109&lt;br&gt;
-109 &amp;#x3C;= target &amp;#x3C;= 109&lt;/p&gt;
&lt;p&gt;只会存在一个有效答案&lt;/p&gt;
&lt;p&gt;进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？&lt;/p&gt;
&lt;h2&gt;思路&lt;/h2&gt;
&lt;p&gt;阅读题目，这个问题可以用：在整数数组中，找出&lt;strong&gt;和为给定整数值&lt;/strong&gt;的两个整数的下标。&lt;/p&gt;
&lt;p&gt;关键是两个数，这两个数的和是给定的，而且这个和的加数只能在给定的数组里面。所以，基于给定的和，对于数组里的每一个整数，另外一个满足条件的被加数都是确定的，如果这个被加数在数组中，获取被加数的下标以及当前加数的下标，就可以返回答案了。&lt;/p&gt;
&lt;p&gt;关键在于如何在数组中找到这个被加数，对于数组中的每一个整数而言，这个问题就变成了，&lt;strong&gt;如何在整数数组中找到一个特定的整数&lt;/strong&gt;，这样就是一个比较简单的问题了。&lt;/p&gt;
&lt;p&gt;我们可以从头到尾遍历一遍这个数组，直到找到目标整数或者遍历到末尾。但是这样对于大规模的数组是十分费时的。为了满足时间限制，我们可以想到用&lt;strong&gt;空间换取时间&lt;/strong&gt;的方法——哈希表。&lt;/p&gt;
&lt;p&gt;我们可以把数组中的所有整数都作为键加入哈希表中，并且以每个整数的下标作为值，利用这个数据结构的特点，我们可以在 O(1) 的时间内找到一个特定整数所在的下标。然后我们再遍历一遍数组，查找对于每个整数其满足条件的另一个整数的下标。&lt;/p&gt;
&lt;p&gt;将所有的整数存入哈希表需要遍历一次数组，对每个整数在哈希表中查找对应的被加数也要遍历一次数组。根据题目的条件，顺序不是重要的，我们可以通过 a 找到 b，也可以通过 b 找到 a，在一开始哈希表是空的，如果先遍历到 a，虽然 a 不能在哈希表中找到它对应的被加数 b，但是当遍历到 b 时，a 已经在哈希表中了，所以我们就可以直接查找到 b，而这个结论对于 a b 在数组中的先后位置反过来的情况依然成立，所以我们可以将循环减少到一次。&lt;/p&gt;
&lt;h2&gt;代码&lt;/h2&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;twoSum&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nums&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; target&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; map &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Map&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// key:整数值,value下标&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; nums&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; curNum &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; nums&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; matchedNum &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; target &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; curNum&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;map&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;has&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;matchedNum&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; map&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;matchedNum&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            map&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;curNum&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum&quot;&gt;1. 两数之和 - 力扣（LeetCode） (leetcode-cn.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[浏览器工作原理——变量提升]]></title><description><![CDATA[总结 JavaScript 引擎在执行之前会先编译，编译过程会将函数的声明和赋值以及由 var…]]></description><link>https://blog-ak8.pages.dev/浏览器工作原理——变量提升/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/浏览器工作原理——变量提升/</guid><pubDate>Sat, 23 Oct 2021 20:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;JavaScript 引擎在执行之前会先&lt;strong&gt;编译&lt;/strong&gt;，编译过程会将&lt;strong&gt;函数的声明和赋值&lt;/strong&gt;以及&lt;strong&gt;由 var 关键字声明的变量的声明&lt;/strong&gt;添加到内存里的执行上下文中，表现为在代码执行阶段，虽然还未执行到某个变量或函数的声明语句，却可以访问该变量而不会报错的一种行为。就像是将这些声明提升到了所有代码的开头。&lt;/p&gt;
&lt;h2&gt;要点&lt;/h2&gt;
&lt;p&gt;程序中的语句通常按照顺序执行，JavaScript 引擎会先编译一遍要执行的 JavaScript 代码，再执行代码。&lt;/p&gt;
&lt;h2&gt;变量提升（hoisting）&lt;/h2&gt;
&lt;p&gt;从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上语句可以分为声明和赋值两句&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; a &lt;span class=&quot;token comment&quot;&gt;// 声明一个变量&lt;/span&gt;
a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 为声明的变量赋值&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;var 关键字声明的变量的声明会提升到作用域开头，但是赋值不会提升。&lt;/p&gt;
&lt;p&gt;JavaScript 的执行过程，先编译，再执行，预编译的作用是什么？是准备执行上下文吗。&lt;/p&gt;
&lt;h2&gt;编译阶段&lt;/h2&gt;
&lt;p&gt;编译阶段会将为要执行的 JavaScript 代码在内存中生成两部分内容：执行上下文和可执行的代码。&lt;/p&gt;
&lt;p&gt;执行上下文是 JavaScript 执行一段代码时的运行环境。执行上下文中存在一个变量环境对象（VariableEnvironment），它保存了当前代码执行环境中的变量。将名称和值绑定起来。在代码执行过程中，JavaScript 引擎在遇到变量名时会在变量环境对象中查找。根据代码顺序，后声明的变量会覆盖之前声明的变量。&lt;/p&gt;
&lt;h2&gt;关于作用域中声明的同名变量和函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。&lt;/li&gt;
&lt;li&gt;如果变量和函数同名，那么在编译阶段，变量的声明会被忽略&lt;/li&gt;
&lt;li&gt;函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;思考题&lt;/h2&gt;
&lt;p&gt;分析输出结果&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;showName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;showName&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;showName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;解答：&lt;/h3&gt;
&lt;p&gt;这段代码交给 JavaScript 引擎之后，JavaScript 引擎先对这段代码进行编译，顺序是从上到下。&lt;/p&gt;
&lt;p&gt;遇到 var 关键词声明了一个 showName 变量，此时将 showName 添加到函数的执行上下文的变量环境对象中，它的值为默认的 undefined。&lt;/p&gt;
&lt;p&gt;随后又遇到了一个函数声明，其声明了名为 showName 的函数，因为在声明同名变量的情况下，函数声明的优先级高于var 声明的变量，所以 showName 变量的值变成函数的地址，&lt;/p&gt;
&lt;p&gt;到了代码的末尾，编译过程结束。&lt;/p&gt;
&lt;p&gt;开始执行代码，是对 showName 这个名字的函数调用，此时 JavaScript 引擎会在执行上下文中查找 showName 这个名字，在执行上下文的变量环境变量中找到了其对应的值，是一个函数，于是对该函数进行调用，结果输出 1。&lt;/p&gt;
&lt;p&gt;然后再执行第二行代码中的赋值部分，将输出 2 的函数赋值给变量 showName。&lt;/p&gt;
&lt;p&gt;执行阶段结束。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[浏览器工作原理——渲染流程（下）]]></title><description><![CDATA[总结 分层：将页面分成多个图层，每个图层可以独立栅格化。 绘制：为每个图层生成对应绘制操作列表，每个绘制操作都代表一个绘图的步骤。 分块：将图层分成若干图块，交给 GPU…]]></description><link>https://blog-ak8.pages.dev/浏览器工作原理——渲染流程（下）/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/浏览器工作原理——渲染流程（下）/</guid><pubDate>Fri, 22 Oct 2021 20:29:00 GMT</pubDate><content:encoded>&lt;h2&gt;总结&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;分层：将页面分成多个图层，每个图层可以独立栅格化。&lt;/li&gt;
&lt;li&gt;绘制：为每个图层生成对应绘制操作列表，每个绘制操作都代表一个绘图的步骤。&lt;/li&gt;
&lt;li&gt;分块：将图层分成若干图块，交给 GPU 进程栅格化。&lt;/li&gt;
&lt;li&gt;栅格化：栅格器由线程池，中的线程根据图块的绘制操作列表，将图块转化成位图数据。&lt;/li&gt;
&lt;li&gt;合成和显示：合成多个图层到内存中，然后显示在屏幕上。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;分层（layer）&lt;/h2&gt;
&lt;p&gt;一个图层是页面的一部分，它可以独立于其他层被变形和栅格化。每个节点都属于一个图层，没有特别指定层级的节点属于父节点的所在的图层。&lt;/p&gt;
&lt;h3&gt;单独提升为一个图层的条件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;拥有堆叠上下文属性的元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;文档的根元素（&lt;code class=&quot;language-text&quot;&gt;&amp;lt;html&gt;&lt;/code&gt;）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;position     属性的值为 absolute（绝对定位）或     relative（相对定位）且 z-index 属性的值不为 auto；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;position 值为     fixed（固定定位）或 sticky（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flex (flexbox) 容器的子元素，且 z-index 值不为 auto；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;grid (grid) 容器的子元素，且 z-index 值不为 auto；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;opacity 属性值小于 1     的元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mix-blend-mode     属性值不为 normal 的元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以下任意属性值不为 none 的元素：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;transform&lt;/li&gt;
&lt;li&gt;filter&lt;/li&gt;
&lt;li&gt;perspective&lt;/li&gt;
&lt;li&gt;clip-path&lt;/li&gt;
&lt;li&gt;mask / mask-image / mask-border&lt;/li&gt;
&lt;li&gt;isolation 属性值为 isolate 的元素；&lt;/li&gt;
&lt;li&gt;-webkit-overflow-scrolling 属性值为 touch 的元素；&lt;/li&gt;
&lt;li&gt;will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；&lt;/li&gt;
&lt;li&gt;contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要被裁切的元素&lt;/p&gt;
&lt;p&gt;当一个元素的内容尺寸超过了元素本身的尺寸，并且指定了 overflow 属性，这时候就产生了裁剪。渲染引擎会把内容的一部分显示在元素区域内。&lt;/p&gt;
&lt;p&gt;出现这种裁剪情况的时候，渲染引擎会为内容元素单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;绘制（paint）&lt;/h2&gt;
&lt;p&gt;绘制过程中为每个图层构建一个&lt;strong&gt;绘制操作（paint ops）列表&lt;/strong&gt;。绘制的顺序是元素的堆叠顺序而不是 DOM 顺序，绘制会分成好几个阶段（backgrounds-&gt;floats-&gt;foregrounds-&gt;outlines-&gt;…），每个阶段都是对堆叠上下文的单独遍历。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4muxL_Nkw6OlPHZshXlEJnnlsue3YpuHpmem2wATf2X83kS_E4uZ6xIVxlJgTL3cZyk1r0PUQTJ2agNg9Mx5mGZ8_3AKgKAC_wgfluAqoj2MGFYQRq6-VUA376h5ZYkO49JQlH9bkDXJvKrgLPqBP2YU4vm3YcM1nweZYq-x7Ce07zIJpelOvWWcvyZvDBW38p?width=1151&amp;#x26;height=527&amp;#x26;cropmode=none&quot; alt=&quot;绘制操作列表&quot; title=&quot;从 DOM树 到布局树再到绘制操作的流程&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mh7Z8bzs3f7LEs1joBMW2lxKrfyTvG1jLsK22Oe7DnoFWowayA9fYuxBXFM6U-oIBOjK-1_HvvaJ-TdsT--BeUv8syInTD4VgAVaphXkJn7Sh1OYIMMqqcbgTasiyNAaazfrVm1uakCLPH7MHd0QentyHmXEFOoFOs0q5S3eqrLXN3SRcncC22TlOqMzVPW7P?width=1151&amp;#x26;height=526&amp;#x26;cropmode=none&quot; alt=&quot;绘制例子&quot; title=&quot;绘制操作详细示例&quot;&gt;&lt;/p&gt;
&lt;h2&gt;栅格化（raster）&lt;/h2&gt;
&lt;p&gt;栅格化将绘制阶段构建的绘制操作列表转换成位图。&lt;/p&gt;
&lt;h2&gt;分块（tilling）&lt;/h2&gt;
&lt;p&gt;绘制操作列表准备好之后，主线程会将图层的绘制操作列表&lt;strong&gt;提交&lt;/strong&gt;给合成器线程。&lt;/p&gt;
&lt;p&gt;图层可能会很大，这样的话栅格化整个图层耗费的代价是十分昂贵的，而且对那些图层中不可见的部分栅格化是完全没必要的。所以合成器线程会将图层分成若干个&lt;strong&gt;图块&lt;/strong&gt;（tiles：瓷砖，瓦片）。&lt;/p&gt;
&lt;h3&gt;栅格化是多线程的&lt;/h3&gt;
&lt;p&gt;图块是栅格化的单元，被分块的若干图块会被一个栅格器线程池中的线程渲染。&lt;strong&gt;越靠近视口的图块越优先被栅格化&lt;/strong&gt;。因为渲染进程是运行在沙盒中，所以无法直接执行操作系统调用。经过绘制后得到的数据被送到 GPU 进程栅格化，所以&lt;strong&gt;栅格器是运行在 GPU 线程中的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mIu1AfxShFTYRtq9511U9ICMTRgyO5HF8MzBhsl1VllEajRW8fgd5d09tL_dsbwtdyPQmn2WTOLj2d46Xsc8JV4dSVhQIKQA-ZK3tlrxkjR_nacACU6TTeQTboYIHBgZZL-wy6uzOHOZbBSRoD9GiMmcDj-csuTM5gGcy72QrCWRyxOrI4o_3Ki3Jc-03F72f?width=1151&amp;#x26;height=531&amp;#x26;cropmode=none&quot; alt=&quot;分块和栅格器线程池&quot; title=&quot;分块和栅格器线程池&quot;&gt;&lt;/p&gt;
&lt;p&gt;栅格化之后生成的位图被存储在内存中，通常是由 OpenGL 纹理对象引用的 GPU 内存。GPU 还可以运行生成位图的命令（“加速栅格化”）。&lt;/p&gt;
&lt;h2&gt;合成与显示&lt;/h2&gt;
&lt;p&gt;图块被栅格化之后，合成器线程会生成一个 DrawQuads 命令，这个命令代表在屏幕上一个特定位置画出图块。这个命令还没有真正地转化成屏幕上的像素，而是对应在内存中的表示。最后再将内存中的数据显示在屏幕上（显示这个步骤很模糊，课程中也是一笔带过）。&lt;/p&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mq3n5KbzaoK7vSk-oJXoHis8oTLw0ac-KhD2JRCFQC-VBGoJVsTfpPFZEQ7hUmuCLvPnc6v-3V3JDDcR7TNvohezCTXdFxSW8baS2yMGyc7gQBM7O8T1MpbGrbPQDqJpvOnHvfz-BxBQARjhLxBFzvG-jll_PF8FvAeoJCxxLv2lk5NDX_YtV637dvhmR-GXw?width=1150&amp;#x26;height=627&amp;#x26;cropmode=none&quot; alt=&quot;从 HTML 到像素的总流程图&quot; title=&quot;从 HTML 到像素的总流程图&quot;&gt;&lt;/p&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_29&quot;&gt;Life of a Pixel（PPT）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[浏览器工作原理——渲染流程（上）]]></title><description><![CDATA[总结 这一章的内容是介绍了浏览器如何让 HTML 变成可交互页面。根据谷歌官网文档的定义，将这一流程称为像素管道（pixel pipeline），课程中更加细致化，多介绍了几个步骤，这些步骤分别是： 构建 DOM…]]></description><link>https://blog-ak8.pages.dev/浏览器工作原理——渲染流程（上）/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/浏览器工作原理——渲染流程（上）/</guid><pubDate>Thu, 21 Oct 2021 18:15:00 GMT</pubDate><content:encoded>&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;这一章的内容是介绍了浏览器如何让 HTML 变成可交互页面。根据谷歌官网文档的定义，将这一流程称为像素管道（pixel pipeline），课程中更加细致化，多介绍了几个步骤，这些步骤分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建 DOM 树&lt;/li&gt;
&lt;li&gt;样式计算&lt;/li&gt;
&lt;li&gt;布局&lt;/li&gt;
&lt;li&gt;分层&lt;/li&gt;
&lt;li&gt;绘制&lt;/li&gt;
&lt;li&gt;栅格化&lt;/li&gt;
&lt;li&gt;合成&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本篇是上篇，主要是讲解从构建 DOM 树到布局的过程。&lt;/p&gt;
&lt;h2&gt;像素管道&lt;/h2&gt;
&lt;p&gt;像素管道是开发者可控的五个主要区域，也是渲染流程的关键点。&lt;br&gt;
&lt;img src=&quot;https://bl3301files.storage.live.com/y4mZBdgKiVfKzbC_YpDBBHyPOGMMuHk6II27hqY0FMXUFjnCIZsblj4yzcqq2sILLIiYPY3MStQl3UHmgN_aWaFygA1b8LTV7KunHSj0LmvZrcc9T4b0jaqvP_stRpjhj6v-Kyq22rj2dPHrRgHItQ9qLh4UEsCdxoz4avT2KeZ34F-6KoTCnyZnLiN1PRpzP3p?width=1093&amp;#x26;height=167&amp;#x26;cropmode=none&quot; alt=&quot;像素管道&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript。一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如用 jQuery 的 &lt;code class=&quot;language-text&quot;&gt;animate&lt;/code&gt; 函数做一个动画、对一个数据集进行排序或者往页面里添加一些 DOM 元素等。当然，除了 JavaScript，还有其他一些常用方法也可以实现视觉变化效果，比如: CSS Animations、Transitions 和 Web Animation API。&lt;/li&gt;
&lt;li&gt;样式计算。此过程是根据匹配选择器（例如 &lt;code class=&quot;language-text&quot;&gt;.headline&lt;/code&gt; 或 &lt;code class=&quot;language-text&quot;&gt;.nav &gt; .nav__item&lt;/code&gt;）计算出哪些元素应用哪些 CSS 规则的过程。从中知道规则之后，将应用规则并计算每个元素的最终样式。&lt;/li&gt;
&lt;li&gt;布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。网页的布局模式意味着一个元素可能影响其他元素，例如 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&gt;&lt;/code&gt; 元素的宽度一般会影响其子元素的宽度以及树中各处的节点，因此对于浏览器来说，布局过程是经常发生的。&lt;/li&gt;
&lt;li&gt;绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。&lt;/li&gt;
&lt;li&gt;合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;构建 DOM 树&lt;/h2&gt;
&lt;p&gt;从之前的章节中介绍过，渲染进程从网络进程中读取当前正在加载的文档的字节流，在接收数据的过程中，渲染器进程的 HTML 解析器会对接收到的数据进行解析，根据 HTML 文件的内容构造出易于解析，查找，和操作的数据结构———— DOM 树。  DOM 树既是文档结构的内部表示，也是暴露给 JavaScript 的 APIs。&lt;/p&gt;
&lt;h3&gt;HTML 解析&lt;/h3&gt;
&lt;p&gt;在本节课程中没有提到 HTML 解析器是如何解析的，但是在后续的内容中有详细的讲解。这里提前做简单介绍。&lt;br&gt;
解析的过程分为分词，解析，添加三个步骤，其中第2，3步是一起进行的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将读取到字节流分成 Token，分为 StartTagToken，EndTagToken 和  文本Token。&lt;/li&gt;
&lt;li&gt;将 Token 解析成 DOM 节点，主要利用了栈结构的特点，第一个阶段生成的 Token 被按顺序压入栈中，并计算节点之间正确的层级关系。具体规则如下：
&lt;ul&gt;
&lt;li&gt;如果压入到栈中的是 &lt;strong&gt;StartTag Token&lt;/strong&gt;，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是&lt;strong&gt;栈中相邻的那个元素生成的节点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果分词器解析出来是&lt;strong&gt;文本 Token&lt;/strong&gt;，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前&lt;strong&gt;栈顶 Token 所对应的 DOM 节点&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果分词器解析出来的是 &lt;strong&gt;EndTag Token&lt;/strong&gt;，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就&lt;strong&gt;将 StartTag div 从栈中弹出&lt;/strong&gt;，表示该 div 元素解析完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;个人对 Token 解析规则的理解&lt;/h4&gt;
&lt;p&gt;如果栈中两个开始标签相邻，就代表后入栈的标签被前一个入栈的标签所包裹，反映在 DOM 树中的关系就是&lt;strong&gt;后入栈的开始标签生成的节点&lt;/strong&gt;是&lt;strong&gt;前一个入栈的标签生成的节点&lt;/strong&gt;的&lt;strong&gt;子节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果当前遍历到的标签是与&lt;strong&gt;当前栈顶的开始标签&lt;/strong&gt;相匹配的&lt;strong&gt;结束标签&lt;/strong&gt;，则说明该标签&lt;strong&gt;没有包裹&lt;/strong&gt;其他的标签，也就代表&lt;strong&gt;对应生成的节点没有子节点&lt;/strong&gt;（但可以有文本节点），此时需要&lt;strong&gt;将栈顶的开始标签弹出&lt;/strong&gt;，相当于向上返回了一层。这样接下来遍历到的开始标签和刚弹出的开始标签会拥有同一个父节点，它们所生成的节点之间就是相邻关系。&lt;/p&gt;
&lt;p&gt;当前栈顶的开始标签就可以代表下一个可能入栈的 token 在树形关系中所处的层级。如果下一个遍历到的 token 是 文本 token，因为文本节点是没有子节点的，所以只需将生成该文本 token 对应的 DOM 节点，并且插入到当前栈顶对应的 DOM 节点下即可。&lt;/p&gt;
&lt;h2&gt;样式计算&lt;/h2&gt;
&lt;h3&gt;CSS 解析&lt;/h3&gt;
&lt;p&gt;CSS 对页面元素的样式起到几乎决定性的作用，然而和 HTML 一样，CSS 也是由人类可读的文本书写，要让程序便于处理，还需要对 CSS 解析，将 CSS 规则转换成便于程序读取操作的结构化的数据——&lt;strong&gt;styleSheets&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;CSSOM 树&lt;/h3&gt;
&lt;p&gt;在一些文档中还包括生成 CSSOM 树的步骤，CSSOM 树和上文的 styleSheets 的作用相同，包含了页面的所有样式，CSSOM 和 DOM树合成渲染树（对应下文的布局树）。渲染树关于功能和结构的描述和下文的布局树类似，只是在布局树的版本中，不存在 CSSOM。&lt;br&gt;
&lt;img src=&quot;https://bl3301files.storage.live.com/y4mvBjLq_0Um1z8zm_Iht_EACq3y4WRJGe6ZIUS1xv3zuEC5ewXMuwr_RfyCvByyerEYHYNkaNyf0uZtBI_HaAQGgljfwu2vIFcQYk021S5O7g_ZAhdv4GfHg1GzTF5UVt4na8BGznVr-LUb6uYxf_oKeaUeQqrjxUfqXo37DhrsKXyA8WrgJG3N08xY3FSKgVp?width=1150&amp;#x26;height=537&amp;#x26;cropmode=none&quot; alt=&quot;CSSOM 树和 DOM 树合成渲染树的示意图&quot;&gt;&lt;br&gt;
貌似这种渲染树模型已经过时了，而最新的版本采用的是布局树，但是网上的大多数资料依然用的渲染树模型，包括 &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction&quot;&gt;Google 开发者官网的文章&lt;/a&gt;和 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work&quot;&gt;MDN 的文章&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;标准化属性值&lt;/h3&gt;
&lt;p&gt;CSS 文本有很多不同的属性值，大多数值可以标准化成同一个种类型的值，例如：2em，2cm，2px，2vh 这样的值在样式计算的过程中都需要将其转换成成统一的 px 值，以便于机器计算。&lt;/p&gt;
&lt;p&gt;元素的样式有&lt;strong&gt;多个来源&lt;/strong&gt;，并且遵循样式&lt;strong&gt;继承&lt;/strong&gt;和&lt;strong&gt;层叠&lt;/strong&gt;规则，元素之间的样式相互影响，为了明确最终绘制在屏幕上的元素的样式，需要根据一些相关的数据计算出每个元素最终的样式。&lt;/p&gt;
&lt;h3&gt;样式的来源&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;行内样式：&lt;code class=&quot;language-text&quot;&gt;&amp;lt;p style=&quot;color: red&quot;&gt;&amp;lt;/p&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;内部样式：&lt;code class=&quot;language-text&quot;&gt;&amp;lt;style type=&quot;text/css&quot;&gt;p { color: red;}&amp;lt;/style&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;外部样式：&lt;code class=&quot;language-text&quot;&gt;&amp;lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;继承规则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;每个 DOM 节点都包含有父节点的样式&lt;/strong&gt;，样式计算过程中，会根据 DOM 节点的继承关系来合理计算节点样式。&lt;/p&gt;
&lt;h3&gt;层叠规则&lt;/h3&gt;
&lt;p&gt;层叠规则定义了&lt;strong&gt;如何合并来自多个源的属性值&lt;/strong&gt;的算法。&lt;/p&gt;
&lt;p&gt;CSS 是渲染阻塞的：浏览器会阻塞页面渲染直到它接收和执行了所有的 CSS。CSS 对象模型随着 CSS 的解析而被构建，但是在完成之前都不能被用来构建渲染树，因为样式将会被之后的解析所覆盖而不应该被渲染到屏幕上。&lt;/p&gt;
&lt;p&gt;总之，样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 &lt;strong&gt;ComputedStyle&lt;/strong&gt; 的结构内。&lt;/p&gt;
&lt;h2&gt;布局&lt;/h2&gt;
&lt;p&gt;在知道对一个元素应用哪些规则之后，浏览器会计算所有元素的几何属性，并且将样式应用到每个元素上。chrome 在布局阶段需要做两件事：创建布局树和布局计算。&lt;/p&gt;
&lt;h3&gt;创建布局树&lt;/h3&gt;
&lt;p&gt;并不是所有的 DOM 节点都需要参与到布局中，那些不可见的节点，例如：应用了 &lt;code class=&quot;language-text&quot;&gt;display: none&lt;/code&gt; 规则的元素，或者是 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;head&gt;&amp;lt;/head&gt;&lt;/code&gt;，等待都不需要参与布局。而布局树中也可能包括 DOM 树中不存在的节点，例如块级元素和行内元素相邻时会为行内元素创建一个块级容器，这也是包含在布局树中的。&lt;br&gt;
&lt;img src=&quot;https://bl3301files.storage.live.com/y4mzUw0-KSiySyDBZp-cLNTl4xhx2LuKLt1_fECaH_qhLkALOfkRZXFpN8Bp5euGOu4e1XCsGLuwTt297GcLrwG3P9SkstEoVZeZ5SN-nyLGH0e_UmuJ5-4-abdgS-R-YJGO2J854wBnFGiA_4GwBU1HCKLzQc_EgKZ-Gv57nFFJuAMdPE1Y0rXcvaAGRVkW-7q?width=1151&amp;#x26;height=530&amp;#x26;cropmode=none&quot; alt=&quot;DOM 树&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mOAEsAaPfLjnH1HdTCSzkH-dm3zy4aZtEvzyAQLNfauDQOqsjfyT-6ezwciFCMJUyl5HictHhyU6pGvWgPtHTdzqXrHfw54x-pOrf0qOJQL3vCC2DjIZSL_PTVKtlI9ogZfRx0bOV3qjUrBqy9y0WK2sQXTjZyR8uDhJEZGUGpU_S-oRACgDLTaGsXkZlZ8x-?width=1151&amp;#x26;height=530&amp;#x26;cropmode=none&quot; alt=&quot;布局树&quot;&gt;&lt;br&gt;
为了创建布局树，浏览器会遍历 DOM 树中所有可见的节点，并将其添加到布局树中，而所有不可见的节点将被忽略。&lt;/p&gt;
&lt;h3&gt;布局计算&lt;/h3&gt;
&lt;p&gt;过程比较复杂，课程中对这个部分省略了。&lt;/p&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path&quot;&gt;关键渲染路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work&quot;&gt;渲染页面：浏览器的工作原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction&quot;&gt;渲染树构建、布局及绘制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jartto.wang/2017/11/13/Exploring-the-principle-of-CSS-parsing/&quot;&gt;探究 CSS 解析原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2018/09/inside-browser-part3&quot;&gt;Inside look at modern web browser (part 3)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=m-J-tbAlFic&amp;#x26;ab_channel=GoogleChromeDevelopers&quot;&gt;Life of a pixel (Chrome University 2019)（视频）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_29&quot;&gt;Life of a Pixel（PPT）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[分析运行时性能]]></title><description><![CDATA[原文：Analyze runtime performance 作者：MSEdgeTeam，mikehoffms，DanishOnGit，jm-trd-ms。 用户往往都期待页面是可交互且丝滑流畅的，而像素管道（pixel pipeline）中的每一个阶段都有可能导致卡顿（jank…]]></description><link>https://blog-ak8.pages.dev/分析运行时性能/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/分析运行时性能/</guid><pubDate>Wed, 20 Oct 2021 23:43:00 GMT</pubDate><content:encoded>&lt;p&gt;原文：&lt;a href=&quot;https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/rendering-tools/&quot;&gt;Analyze runtime performance&lt;/a&gt;&lt;br&gt;
作者：&lt;a href=&quot;https://github.com/MSEdgeTeam&quot;&gt;MSEdgeTeam&lt;/a&gt;，&lt;a href=&quot;https://github.com/mikehoffms&quot;&gt;mikehoffms&lt;/a&gt;，&lt;a href=&quot;https://github.com/DanishOnGi&quot;&gt;DanishOnGit&lt;/a&gt;，&lt;a href=&quot;https://github.com/jm-trd-ms&quot;&gt;jm-trd-ms&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;用户往往都期待页面是可交互且丝滑流畅的，而像素管道（pixel pipeline）中的每一个阶段都有可能导致卡顿（jank）。本文帮助你学习如何识别和修复常见的可能导致运行时性能问题，以及相关的工具。&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不要写强制浏览器重新计算布局的 JavaScript。分离读和写函数，并且优先执行读操作。&lt;/li&gt;
&lt;li&gt;不要让你的 CSS 过于复杂。使用更少的 CSS 并且保持你的 CSS 选择器简单。&lt;/li&gt;
&lt;li&gt;尽可能避免浏览器布局操作（layout），选择使用那些完全不会触发布局的 CSS。&lt;/li&gt;
&lt;li&gt;绘制（painting）可能比任何其他的渲染活动花上更多的时间。注意绘制瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;JavaScript&lt;/h2&gt;
&lt;p&gt;JavaScript 计算，尤其是触发昂贵的视觉变化的那种，可能会拖慢应用的性能。不要让时机不恰当或长时间运行的 JavaScript 干扰用户的交互。&lt;/p&gt;
&lt;h3&gt;JavaScript：工具&lt;/h3&gt;
&lt;p&gt;使用 &lt;strong&gt;Performance&lt;/strong&gt; 工具录制，找出运行时间长得离谱的&lt;code class=&quot;language-text&quot;&gt;执行脚本（Evaluate Script）&lt;/code&gt; 事件。&lt;/p&gt;
&lt;p&gt;如果你发现你的 JavaScript 执行过程频繁卡顿（渲染的中断），你可能需要更进一步地分析并且收集一份 JavaScript CPU 概况（profiles）。CPU 概况展示了页面中函数的运行时间花费在了哪里。你可以在&lt;a href=&quot;https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/rendering-tools/js-runtime&quot;&gt;Speed up JavaScript runtime&lt;/a&gt;中学习怎样创建 CPU 概况。&lt;/p&gt;
&lt;h3&gt;JavaScript：问题&lt;/h3&gt;
&lt;p&gt;下面这个表格描述了一些常见的 JavaScript 问题和可能的方法。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问题&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;解决方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;昂贵的输入处理程序影响页面响应和动画。&lt;/td&gt;
&lt;td&gt;触摸，视差滚动&lt;/td&gt;
&lt;td&gt;让浏览器去处理触摸和滚动，或者尽量推迟事件监听器的绑定。 推荐阅读文章 &lt;a href=&quot;https://calendar.perfplanet.com/2013/the-runtime-performance-checklist/&quot;&gt;Expensive Input Handlers in Paul Lewis’ runtime performance checklist&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;时机不恰当的 JavaScript 影响页面响应，动画，和加载&lt;/td&gt;
&lt;td&gt;用户在页面加载完成后向右滚动，setTimeout / setInterval。&lt;/td&gt;
&lt;td&gt;使用 JavaScript 运行时：用 &lt;code class=&quot;language-text&quot;&gt;requestAnimationFrame&lt;/code&gt; 将 DOM 操作分散到各帧中，使用 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers&quot;&gt;Web Workers&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;长时间运行的 JavaScript 影响页面响应&lt;/td&gt;
&lt;td&gt;太多的 JS 工作导致 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers&quot;&gt;DOMContentLoaded&lt;/a&gt; 事件被延迟&lt;/td&gt;
&lt;td&gt;把单纯的计算工作移至 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/Web_Workers_API/Using_web_workers&quot;&gt;Web Workers&lt;/a&gt;。如果你需要访问 DOM，那就使用 &lt;code class=&quot;language-text&quot;&gt;requestAnimationFrame&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;垃圾脚本影响页面响应或者动画&lt;/td&gt;
&lt;td&gt;垃圾收集可能发生在任何地方&lt;/td&gt;
&lt;td&gt;写更少的垃圾脚本，推荐阅读文章 &lt;a href=&quot;https://calendar.perfplanet.com/2013/the-runtime-performance-checklist/&quot;&gt;Garbage Collection in Animation in Paul Lewis’ runtime performance checklist&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;样式&lt;/h2&gt;
&lt;p&gt;改变样式的开销也很大，尤其是当这些改变影响多个 DOM 中的元素的时候。当你对一个元素应用样式时，浏览器会计算出所有相关元素的影响，重新计算布局并重新绘制。&lt;/p&gt;
&lt;h3&gt;样式：工具&lt;/h3&gt;
&lt;p&gt;使用 &lt;strong&gt;Performance&lt;/strong&gt; 工具做记录，检查大型的 &lt;code class=&quot;language-text&quot;&gt;Recalculate Style&lt;/code&gt; 事件（紫色显示）。&lt;/p&gt;
&lt;p&gt;选择一个 &lt;code class=&quot;language-text&quot;&gt;Recalculate Style&lt;/code&gt; 事件，在 &lt;strong&gt;Details&lt;/strong&gt; 面板查看更多的相关信息。如果这个样式改变花了太长时间，那这就是一个性能问题。如果这个样式计算影响了很多元素，那这就有可改进的空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mTIdlYB-BTSXaD6MhNEs7LRC7rz5VfuTrzrJtxeLj5D5FZLaDdeEJ3EnIwmEVHsNYVkZjUsKMiN1GBEorwe2CufY07LpTcytPlWKaHD34NLRIEaC8DyrNa_2_DOnu16fAfXj_8XwpuhqpweHJdCo1gcQU1Skn8nue-Rib8dk6j3xKC-08L4VrH6o6wlwjlPVk?width=1862&amp;#x26;height=1078&amp;#x26;cropmode=none&quot; alt=&quot;rendering-tools-performance-recalculate-style-summary.msft&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了减少 &lt;code class=&quot;language-text&quot;&gt;Recalculate Style&lt;/code&gt; 事件的影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://csstriggers.com/&quot;&gt;CSS Triggers&lt;/a&gt; 来了解哪些 CSS 属性会触发布局，绘制，和合成。这些属性对渲染性能的影响最大。&lt;/li&gt;
&lt;li&gt;换成影响较小的属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;样式：问题&lt;/h3&gt;
&lt;p&gt;下面这个表格描述了一些常见的样式问题和可能的方法。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问题&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;解决方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;昂贵的样式计算影响页面响应和动画。&lt;/td&gt;
&lt;td&gt;任何改变元素形状的 CSS 属性，比如宽度，高度，或者位置；浏览器会检查其他所有的元素并且重新计算布局。&lt;/td&gt;
&lt;td&gt;避免触发布局的 CSS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;复杂的选择器计算影响页面响应和动画。&lt;/td&gt;
&lt;td&gt;嵌套选择器迫使浏览器了解所有其他元素的一切，包括父元素和子元素。&lt;/td&gt;
&lt;td&gt;在你的CSS中用 class 引用一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;布局&lt;/h2&gt;
&lt;p&gt;布局（在 Firefox 中又称重排）是浏览器计算页面中所有元素的位置和尺寸的过程。web 的布局模型意味着元素之间可能会互相影响；例如 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&gt;&lt;/code&gt; 元素的宽度通常会影响它的任何子元素的宽度，以此类推，从树上一直向下。对于浏览器来说，这个过程可能相当复杂。&lt;/p&gt;
&lt;p&gt;根据经验来说，如果你在一帧完成之前要求 DOM 返回一个几何属性的值，你会发现你触发了 “强制同步布局”，如果经常重复对大型 DOM 树执行的话，这将是一个很大的性能瓶颈。&lt;/p&gt;
&lt;h3&gt;布局：工具&lt;/h3&gt;
&lt;p&gt;占位&lt;/p&gt;
&lt;h3&gt;布局：问题&lt;/h3&gt;
&lt;p&gt;下面这个表格描述了一些常见的布局问题和可能的方法。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问题&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;解决方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;强制同步布局影响页面响应和动画。&lt;/td&gt;
&lt;td&gt;强制浏览器在像素管道中过早地执行布局，导致渲染过程中的重复步骤。&lt;/td&gt;
&lt;td&gt;先批量读取样式，然后再进行样式的任何写入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;布局抖动影响页面响应和动画。&lt;/td&gt;
&lt;td&gt;一个将浏览器置于读-写-读-写循环的循环语句会迫使浏览器一遍又一遍地重新计算布局。&lt;/td&gt;
&lt;td&gt;使用 &lt;a href=&quot;https://github.com/wilsonpage/fastdom&quot;&gt;FastDom&lt;/a&gt; 库自动进行批量读写操作。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;绘制和合成（Paint and composite）&lt;/h2&gt;
&lt;p&gt;绘制是填充像素的过程。它往往是渲染过程中性能花销最大的部分。如果你注意到你的页面没有达到设计的效果，那很可能是你的绘制部分出了问题。&lt;/p&gt;
&lt;p&gt;合成是将页面上的绘画部分放在一起在屏幕上显示的地方。在大多数情况下，如果你坚持只使用合成器属性而完全避免绘制，这会给为你的页面带来性能的重大改善，但你需要当心层数过多。&lt;/p&gt;
&lt;h3&gt;绘制和合成：工具&lt;/h3&gt;
&lt;p&gt;想知道绘制需要多长时间或绘制发生的频率吗？勾选 &lt;strong&gt;Performance&lt;/strong&gt; 面板中的&lt;a href=&quot;https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/evaluate-performance/reference#turn-on-advanced-paint-instrumentation&quot;&gt;启用高级绘制仪器（Enable advanced paint instrumentation）&lt;/a&gt;设置，然后进行录制。如果你的大部分渲染时间都花在了绘制上，你就有绘制问题了。&lt;/p&gt;
&lt;h3&gt;绘制和合成：问题&lt;/h3&gt;
&lt;p&gt;下面这个表格描述了一些常见的绘制和合成问题和可能的方法。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;问题&lt;/th&gt;
&lt;th&gt;例子&lt;/th&gt;
&lt;th&gt;解决方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;绘制风暴影响页面响应和动画。&lt;/td&gt;
&lt;td&gt;大的绘制区域，或者昂贵的绘制影响页面响应和动画。&lt;/td&gt;
&lt;td&gt;避免绘制，将正在移动的元素提升到自己的层，使用 transform 和 opacity。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;过多的元素的提升，大大影响了动画的性能。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;谨慎地提升图层，只有当你知道它提供了切实的改进时才会提升。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution&quot;&gt;优化 JavaScript 执行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/rendering/reduce-the-scope-and-complexity-of-style-calculations&quot;&gt;缩小样式计算的范围并降低其复杂性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing&quot;&gt;避免大型、复杂的布局和布局抖动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/rendering/simplify-paint-complexity-and-reduce-paint-areas&quot;&gt;简化绘制的复杂度、减小绘制区域&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[浏览器工作原理——导航流程]]></title><description><![CDATA[总结 从多个进程的角度，解释从浏览器接受到 URL 到页面显示中间的一些过程。重点主要是导航的过程，包括以地址栏输入 URL…]]></description><link>https://blog-ak8.pages.dev/浏览器工作原理——导航流程/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/浏览器工作原理——导航流程/</guid><pubDate>Sun, 17 Oct 2021 11:55:00 GMT</pubDate><content:encoded>&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;从多个进程的角度，解释从浏览器接受到 URL 到页面显示中间的一些过程。重点主要是导航的过程，包括以地址栏输入 URL 的方式打开新的页面，或者从一个页面的链接跳转到另一个页面。&lt;/p&gt;
&lt;p&gt;文章的特点是说到了多个进程之间的通信和协作。主要是网络进程，浏览器进程，渲染进程之间的通信。在 Google 官方的文档中，分为浏览器进程，和渲染进程。其中浏览器进程包括 UI 线程，存储线程，网络线程。&lt;/p&gt;
&lt;h2&gt;导航流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h3&gt;处理输入（浏览器进程-&gt;UI 线程）&lt;/h3&gt;
&lt;p&gt;用户在地址栏输入时，UI 线程会判断所输入的字符串是查询搜索还是 URL？如果是查询搜索则将查询内容发送到默认搜索引擎。如果是 URL 则发送到 URL 对应的网站。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;向 URL 发送请求（浏览器进程-&gt;网络线程）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;查找缓存&lt;/strong&gt;&lt;br&gt;
网络进程会根据缓存机制查找缓存，如果缓存不可用，则需要发送请求进入网络请求流程。&lt;/p&gt;
&lt;p&gt;缓存过期，Last-Modified/If-Last-Modified，Etag/If-None-Modified，Expire，Cache-Control。200，304。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DNS 解析&lt;/strong&gt;&lt;br&gt;
依次从浏览器 DNS 缓存，到本机的 host 文件，再发送 DNS 查询。递归查询。从根域名服务器遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TCP 连接&lt;/strong&gt;&lt;br&gt;
三次握手：SYN, SYN-ACK, ACK，四次挥手，传输控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TLS 连接&lt;/strong&gt;&lt;br&gt;
认证加密，重点是认证中心是可信的，认证中心将信任通过证书授予到某个 web 服务器。客户端通过认证中心的公钥解密证书，确认证书可信从而确认与之一同被发送的 web 服务器的公钥可信。再通该可信的公钥加密密钥，发送给当前连接中与之通信的 web 服务器，如果对方是同一个 web 服务器，那么就应该拥有对应的私钥，就能够解密数据从而取出密钥。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据传输&lt;/strong&gt;&lt;br&gt;
发送请求行，请求头，请求体。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;阅读响应（浏览器进程-&gt;网络线程）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;br&gt;
一旦收到响应体数据开始，网络线程根据响应头数据分析响应体的数据类型，并且更具不同的数据类型决定下一步。如果响应是 HTML 文件类型，则下一步的目的就是将数据传递给渲染进程，如果是 zip 文件类型或者其他文件请求，则需要将数据传递给下载管理器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重定向&lt;/strong&gt;&lt;br&gt;
如果响应头中的状态码为 301 或 302，则需要重定向，重定向的地址为响应头中的 Location 字段。然后重新发起新的请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全检查&lt;/strong&gt;&lt;br&gt;
这也是安全中断检测发生的地方。如果域名和响应数据被检测为恶意网站，则网络线程会发出警报以显示警告页面。此外 Cross Origin Read Block 检查的发生，以确保敏感的跨站点数据不会进入渲染过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;查找渲染进程（浏览器进程-&gt;网络线程 到 浏览器进程-&gt;UI 线程 到 渲染进程）&lt;/h3&gt;
&lt;p&gt;完成安全检查之后，网络线程确信浏览器应该导航到请求的站点，网络线程通知 UI 线程数据已经准备就绪，然后 UI 线程找到一个渲染进程对网页进行渲染。&lt;/p&gt;
&lt;p&gt;由于网络请求可能需要几百毫秒才能得到响应，所以 UI 线程可以在网络线程收到响应数据之前尝试主动查找或启动与网络线程发送请求并行的渲染进程。当网络线程接受数据时，渲染进程已经准备就绪了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;提交导航（浏览器线程 -&gt; 渲染线程）&lt;/h3&gt;
&lt;p&gt;网络线程的响应数据和渲染进程都准备就绪时，浏览器进程将通过 IPC 通知渲染进程“提交导航”，此外浏览器进程还会将数据流传递给渲染进程，以便渲染进程可以继续接收响应数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;确认提交（渲染线程 -&gt; 浏览器线程）&lt;/h3&gt;
&lt;p&gt;渲染线程接受完响应数据之后，通过 IPC 向浏览器进程发送“确认提交”的消息。此时导航阶段就完成了，进入文档加载阶段。&lt;/p&gt;
&lt;p&gt;浏览器进程的 UI 线程会更新地址栏，安全指示器，和站点设置的 UI以反映新页面的站点信息。选项卡的会话历史记录也将更新，会话历史记录存储在磁盘上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;提交文档阶段&lt;/h2&gt;
&lt;p&gt;浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络进程下载并读取响应头数据。&lt;/li&gt;
&lt;li&gt;网络进程响应头数据下载并读取完毕后通知并将响应头数据发送给浏览器进程。&lt;/li&gt;
&lt;li&gt;浏览器进程通知渲染进程“提交文档”并将渲染头数据转发给渲染进程。&lt;/li&gt;
&lt;li&gt;渲染进程收到“提交文档”的消息以及响应头数据后，与网络进程建立数据传输的“管道”，直接从网络进程接收剩下的响应体数据。&lt;/li&gt;
&lt;li&gt;响应体数据传输完毕之后，渲染进程发送“确认提交”的消息给浏览器进程。&lt;/li&gt;
&lt;li&gt;浏览器进程收到“确认提交”的消息后，会更新浏览器界面状态，包括安全状态、地址栏的 URL、前进后退的历史状态、并更新页面。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;渲染阶段&lt;/h2&gt;
&lt;p&gt;Content-Type 决定浏览器对响应的处理方式，可能是转到下载管理器，也可能是当作网页处理（text/HTML）。&lt;/p&gt;
&lt;h2&gt;共用渲染进程&lt;/h2&gt;
&lt;p&gt;多个网页可能会公用一个渲染进程，取决于它们所属的站点和打开的方式：如果从 A 页面打开 B 页面，且 A 和 B 属于同一站点，那么 B 页面会 复用 A 页面的渲染进程，否则新打开的页面会使用单独的渲染进程。&lt;/p&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2018/09/inside-browser-part2&quot;&gt;Inside look at modern web browser (part 2)  |  Web  |  Google Developers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work&quot;&gt;渲染页面：浏览器的工作原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[浏览器工作原理——HTTP请求流程]]></title><description><![CDATA[HTTP 请求流程 HTTP 请求流程示意图 构建请求 查找缓存 准备 IP 地址和端口 等待 TCP 队列 建立 TCP 连接 发起 HTTP 请求 发送请求行 发送请求头 服务器处理请求 服务器返回请求行 服务器返回响应头 服务器返回响应体 断开 TCP…]]></description><link>https://blog-ak8.pages.dev/浏览器工作原理——HTTP请求流程/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/浏览器工作原理——HTTP请求流程/</guid><pubDate>Sun, 17 Oct 2021 11:14:00 GMT</pubDate><content:encoded>&lt;h2&gt;HTTP 请求流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4msr6Uc6wYHTsbX_u5y-DOad3OueQXHcOqb1MGUUNZPY-VZL5DWNP1xU1HNF5rQfDPO54I-mImOk9J2Q_dJxsARjxkWQpyd9NeQDoogErqBO1UaGTZVbss1JGHOba9ENbuJX_NejYXzcBd86dQRLP7VgGDGkmRNv1U0xvhtvW19KrZLJBtsurVtmG1lA4djMLy?width=1142&amp;#x26;height=423&amp;#x26;cropmode=none&quot; alt=&quot;HTTP 请求流程示意图&quot; title=&quot;HTTP 请求流程示意图&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构建请求&lt;/li&gt;
&lt;li&gt;查找缓存&lt;/li&gt;
&lt;li&gt;准备 IP 地址和端口&lt;/li&gt;
&lt;li&gt;等待 TCP 队列&lt;/li&gt;
&lt;li&gt;建立 TCP 连接&lt;/li&gt;
&lt;li&gt;发起 HTTP 请求
&lt;ul&gt;
&lt;li&gt;发送请求行&lt;/li&gt;
&lt;li&gt;发送请求头&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务器处理请求
&lt;ul&gt;
&lt;li&gt;服务器返回请求行&lt;/li&gt;
&lt;li&gt;服务器返回响应头&lt;/li&gt;
&lt;li&gt;服务器返回响应体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;断开 TCP 连接&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;浏览器缓存&lt;/h2&gt;
&lt;h3&gt;强缓存&lt;/h3&gt;
&lt;p&gt;不会向服务器发送任何请求，直接从本地缓存中读取并且返回状态码：200 OK。
200 from memory cache：缓存在内存中，从内存中读取，浏览器关闭则丢失。
200 from disk cache：缓存在磁盘中，从磁盘中读取，浏览器关闭仍然存在。&lt;br&gt;
优先级：memory cache &gt; disk cache &gt; network&lt;/p&gt;
&lt;h3&gt;协商缓存&lt;/h3&gt;
&lt;p&gt;向服务器发送请求，服务器根据这个请求头部中的一些参数判断是否命中协商缓存，如果命中，则返回 304 状态码，并带上新的响应头部通知浏览器从缓存中读取资源。
&lt;img src=&quot;https://bl3301files.storage.live.com/y4mulom0HnZDweCxsXb1AGyz8wwE_5m_talDCI9hWol5x2HjRVyMVD_CeIBV7Rr_AuYegs5eW715ER9NRf5a7-SZE7LgsEHEYff99S015zMVUp2EE8TAmErXCkzGTV7xJS9sDQKg_dAUe15WJaD9JybZogDADtYJvABx8XCZDLhfGI7MNZYGrbz2hRZAD1uNvly?width=627&amp;#x26;height=884&amp;#x26;cropmode=none&quot; alt=&quot;浏览协商缓存机制流程图&quot; title=&quot;浏览协商缓存机制流程图&quot;&gt;&lt;/p&gt;
&lt;p&gt;Last-Modifed/If-Modified-Since 和 Etag/If-None-Match 是分别成对出现的，呈一一对应关系。“/”之前的字段是在响应头中的，“/”之后的字段是请求头中的。当响应被缓存时，浏览器根据缓存中对应资源的的响应头中的 Etag 和 Last-Modifed 字段判断是否在请求头中附加 If-Modified-Since 和 If-None-Match 字段。&lt;/p&gt;
&lt;p&gt;Etag：&lt;br&gt;
Etag是属于HTTP 1.1属性，它是由服务器（Apache 或者其他工具）生成返回给前端，用来帮助服务器控制 Web 端的缓存验证。 Apache 中，Etag 的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。&lt;/p&gt;
&lt;p&gt;If-None-Match:&lt;br&gt;
当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器请求时带上请求头 If-None-Match(值是 Etag 的值)。服务器收到请求进行比对，决定返回 200 或 304。&lt;/p&gt;
&lt;p&gt;Last-Modified：
源服务器认为资源最后的修改时间&lt;/p&gt;
&lt;p&gt;If-Modified-Since：
当资源过期时（浏览器判断 Cache-Control 标识的 max-age 过期），发现响应头具有 Last-Modified 声明，则再次向服务器请求时带上头 If-Modified-Since，表示请求时间。服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Last-Modifed/If-Modified-Since 的时间精度是秒，而 Etag 可以更精确。&lt;/li&gt;
&lt;li&gt;Etag优先级是高于Last-Modifed 的，所以服务器会优先验证 Etag&lt;/li&gt;
&lt;li&gt;Last-Modifed/If-Modified-Since 是http1.0的头字段&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;DNS&lt;/h2&gt;
&lt;p&gt;HTTP 协议是基于 TCP/IP 的，建立 TCP 连接需要 IP 地址，对于用户而言代表网络资源的 URL 中提供的都是便于记忆的域名，所以就需要 DNS 将域名转换成 IP，浏览器提供 DNS 缓存。&lt;/p&gt;
&lt;h2&gt;最大连接数&lt;/h2&gt;
&lt;p&gt;同一个域名下最多拥有 6 个已建立的 TCP 连接。多出的请求会排队等待，直至有可用的连接。&lt;/p&gt;
&lt;h2&gt;请求行格式&lt;/h2&gt;
&lt;h3&gt;HTTP 请求行&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;请求方法&lt;/th&gt;
&lt;th&gt;请求URL&lt;/th&gt;
&lt;th&gt;协议版本&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;/library?search=news&lt;/td&gt;
&lt;td&gt;HTTP/1.1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;HTTP 响应行&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;协议版本&lt;/th&gt;
&lt;th&gt;状态码&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HTTP/1.1&lt;/td&gt;
&lt;td&gt;200 OK&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content:encoded></item><item><title><![CDATA[浏览器工作原理——TCP协议]]></title><description><![CDATA[总结 网络的分层结构，下层对上层交付
数据以包的形式传输，数据包分成头部和数据体，上层的包经过底层，会被当作底层的数据体，进行再一次封装，附加上底层的一些传输所需的信息。数据包从底层到上层会被层层解析并且去除头部。 TCP、UDP：源端口 到 目的端。
IP： 源 IP…]]></description><link>https://blog-ak8.pages.dev/浏览器工作原理——TCP协议/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/浏览器工作原理——TCP协议/</guid><pubDate>Sun, 17 Oct 2021 10:14:00 GMT</pubDate><content:encoded>&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;网络的分层结构，下层对上层交付
数据以包的形式传输，数据包分成头部和数据体，上层的包经过底层，会被当作底层的数据体，进行再一次封装，附加上底层的一些传输所需的信息。数据包从底层到上层会被层层解析并且去除头部。&lt;/p&gt;
&lt;p&gt;TCP、UDP：源端口 到 目的端。
IP： 源 IP 地址 到 目的 IP 地址。&lt;/p&gt;
&lt;p&gt;IP 协议标识网络中的每一个端点&lt;/p&gt;
&lt;p&gt;TCP 是面向连接的可靠的传输，保证传输数据的完整性，会对丢失数据包重传。TCP还可以控制传输的速度。&lt;/p&gt;
&lt;p&gt;面向连接：每次传输之前需要在源端口和目的端口之间建立一个连接（三次握手，四次挥手），再开始数据的传输，之后的数据传输都是基于这个连接。
TCP 连接的三个阶段
1. 建立连接
2. 传输数据
3. 断开连接&lt;/p&gt;
&lt;p&gt;可靠传输：TCP 协议会对发出的数据是否正确到达（未丢失，内容校验）进行确认，如果没有正确到达则会重传以保证传输的可靠性。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[浏览器工作原理——chrome架构]]></title><description><![CDATA[…]]></description><link>https://blog-ak8.pages.dev/浏览器工作原理——chrome架构/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/浏览器工作原理——chrome架构/</guid><pubDate>Fri, 15 Oct 2021 20:34:00 GMT</pubDate><content:encoded>&lt;h2&gt;进程：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;正在执行的程序。&lt;/li&gt;
&lt;li&gt;正在计算机上执行的程序实例。&lt;/li&gt;
&lt;li&gt;能分配给处理器并由处理器执行的实体。&lt;/li&gt;
&lt;li&gt;具有以下特征的活动单元：一组指令序列的执行，一个当前状态和相关系统资源集。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程的两个基本元素：程序代码和代码相关联的数据集。&lt;/p&gt;
&lt;h2&gt;线程：&lt;/h2&gt;
&lt;p&gt;程序执行的路径。可被操作系统调度和分派的实体。&lt;/p&gt;
&lt;h2&gt;进程和线程的特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个进程可以包含多个线程。&lt;/li&gt;
&lt;li&gt;线程之间可以共享进程中的数据。&lt;/li&gt;
&lt;li&gt;进程与进程之间的资源（内存，文件操作符，套接字，CPU等）相互隔离，通过 IPC 机制互相通信。&lt;/li&gt;
&lt;li&gt;进程关闭后，操作系统会回收其所占用的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;单进程架构&lt;/h2&gt;
&lt;p&gt;以前的浏览器采用的单线程，网络，页面渲染，浏览器界面，均在同一个进程中。&lt;/p&gt;
&lt;h3&gt;缺点：&lt;/h3&gt;
&lt;p&gt;在于不同的工作模块的隔离性差，可能会相互影响，影响主要在一以下几个方面。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;稳定性&lt;br&gt;
一个进程中一个线程的崩溃可能会导致整个进程崩溃，产生不必要的影响。&lt;/li&gt;
&lt;li&gt;性能&lt;br&gt;
一个进程负责负责任务太多，不能充分利用并发优势，一个线程有可能会被其他的线程阻塞。&lt;/li&gt;
&lt;li&gt;安全性&lt;br&gt;
一个进程中的多个线程可以共享数据，JavaScript 执行线程可能访问浏览器进程中的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;现代多进程架构&lt;/h2&gt;
&lt;p&gt;新的架构包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器进程&lt;/li&gt;
&lt;li&gt;GPU 进程&lt;/li&gt;
&lt;li&gt;网络进程&lt;/li&gt;
&lt;li&gt;多个渲染进程&lt;/li&gt;
&lt;li&gt;多个插件进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;渲染进程&lt;/h3&gt;
&lt;p&gt;渲染进程将 HTML、CSS、JavaScript 转换成可交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。渲染进程都是运行在沙箱模式下。&lt;/p&gt;
&lt;h3&gt;优势&lt;/h3&gt;
&lt;p&gt;将不同职责的任务分配到多个进程，进程之间相互隔离。大大减小了不同模块之间的影响。并且每个网页都会分配渲染进程，网页之间互相影响的可能性更小，并且每个渲染进程都运行在沙箱中，提高了安全性。&lt;/p&gt;
&lt;h3&gt;缺陷&lt;/h3&gt;
&lt;p&gt;资源占用更高&lt;/p&gt;
&lt;h2&gt;面向服务的架构（未来）&lt;/h2&gt;
&lt;p&gt;各个模块被分成服务，每个服务在独立的进程中运行，服务暴露出接口，通过 IPC 来通信。目的是构建高内聚，松耦合，易于维护和扩展的系统。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;主要是介绍了目前浏览器的架构，不同线程负责的模块，以及浏览器架构的发展。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[夏夜晚风]]></title><description><![CDATA[夏夜里繁星在黑色夜空，阵阵虫鸣和晚风。]]></description><link>https://blog-ak8.pages.dev/夏夜晚风/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/夏夜晚风/</guid><pubDate>Thu, 07 Oct 2021 19:17:00 GMT</pubDate><content:encoded>&lt;p&gt;夏夜里繁星在黑色夜空，阵阵虫鸣和晚风。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React Fiber 架构]]></title><description><![CDATA[原文：React Fiber Architecture 作者：acdlite React Fiber 是一个正在进行的 React 的核心算法的重新实现。 React Fiber…]]></description><link>https://blog-ak8.pages.dev/React Fiber 架构/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/React Fiber 架构/</guid><pubDate>Wed, 29 Sep 2021 14:01:00 GMT</pubDate><content:encoded>&lt;p&gt;原文：&lt;a href=&quot;https://github.com/acdlite/react-fiber-architecture&quot;&gt;React Fiber Architecture&lt;/a&gt;&lt;br&gt;
作者：&lt;a href=&quot;https://twitter.com/acdlite&quot;&gt;acdlite&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;React Fiber 是一个正在进行的 React 的核心算法的重新实现。&lt;/p&gt;
&lt;p&gt;React Fiber 的目标就是增强对动画，布局，和手势等领域的适应性。它的头号特性就是&lt;strong&gt;增量渲染&lt;/strong&gt;：一种将渲染工作拆分成多个更小的部分并且把这些部分的工作分摊到多个帧上的能力。&lt;/p&gt;
&lt;p&gt;其他的关键特性包括暂停的能力，终止的能力，当新的更新到来时重用工作的能力；为不同类型的更新指定优先级的能力；还有新的并发原语（concurrency primitives）。&lt;/p&gt;
&lt;h2&gt;关于这个文档&lt;/h2&gt;
&lt;p&gt;Fiber 引入了几个新的概念，这些概念光看代码很难完全理解。这个文档开始是我在追随 Fiber 在 React 项目中的实现的过程中做的笔记的集合，随着它的增长，我意识到它可能也是一个对别人很有帮助的资源。&lt;/p&gt;
&lt;p&gt;我将尝试用尽可能简朴的语言，并通过解释定义关键术语来避免行话，如果可能，我也会大量连接到外部的资源。&lt;/p&gt;
&lt;p&gt;请注意，我并不是 React 团队的成员，而且没有任何权威的发言权。&lt;strong&gt;这不是一个官方文档&lt;/strong&gt;。我已经要求 React 团队的成员审查过它的准确性。&lt;/p&gt;
&lt;p&gt;这也是一个正在施工中的工作，&lt;strong&gt;Fiber 是一个正在进行中的项目，在完成之前可能会进行重大的重构&lt;/strong&gt;。此外，我还在尝试在这里记录它的设计。我非常欢迎提出改进和建议。&lt;/p&gt;
&lt;p&gt;我的目标是在读完这篇文档之后，你将对 Fiber 有足够的了解，以便在它的实现过程中进行跟进，最终能够为 React 做出贡献。&lt;/p&gt;
&lt;h2&gt;阅读之前的准备&lt;/h2&gt;
&lt;p&gt;我强烈建议你在继续阅读之前熟悉下面这些资源:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html&quot;&gt;React 组件，元素，和实例&lt;/a&gt;-“组件是一个经常被重载的术语，牢牢掌握这些术语至关重要”&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/docs/reconciliation.html&quot;&gt;Reconciliation&lt;/a&gt;-一个对 React 的协调算法的高级的描述。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/reactjs/react-basic&quot;&gt;React 基本理论概念&lt;/a&gt;-对 React 的概念模型的描述，不用理解具体的实现。其中一些内容在初读时可能没有意义，没有关系，随着时间的推移，它将变得更有意义。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;回顾&lt;/h2&gt;
&lt;h2&gt;什么是协调（reconciliation）&lt;/h2&gt;
&lt;h3&gt;协调（reconciliation）&lt;/h3&gt;
&lt;p&gt;React 用来将一棵树和另外一棵树进行比较，以确定哪些部分需要被改变的算法。&lt;/p&gt;
&lt;h3&gt;更新&lt;/h3&gt;
&lt;p&gt;用来渲染 React 应用的数据的一次改变，通常是由 ‘setState’ 引起的。最终导致重新渲染（re-render）。&lt;/p&gt;
&lt;p&gt;React API 的中心思想就是将更新看作是导致整个应用程序重新渲染。这允许开发者以声明的方式进行推理，而不是担心如何有效地将应用从任何一个特定的状态转换到另一个特定的状态（A 到 B，B 到 C，C 到 A，等等）。&lt;/p&gt;
&lt;p&gt;实际上在每次更改后都重新渲染整个应用程序仅适用于最琐碎的应用程序；在一个真正的应用程序中，这种做法的性能成本太高了。React 进行了优化，可以在保持出色性能的同时创建整个应用程序重新渲染的外观。这些优化中的大部分是一个被称之为 &lt;strong&gt;reconciliation（以下称为协调）&lt;/strong&gt; 的过程的一部分。&lt;/p&gt;
&lt;p&gt;协调是通常被理解为 “虚拟 DOM（virtual DOM）”背后的算法。一个高级描述像这样：当你渲染一个 React 应用程序，就会有一棵由多个节点组成，用来描述这个应用程序的树被生成，并且被保存在内存中。然后，这棵树将被刷新到渲染环境中——例如，在浏览器应用程序的情况下，它被转换成一系列 DOM 操作。每当应用程序更新（通常是通过 &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt;）时，就会生成一棵新的树。这棵新的树和之前的那棵树进行比较，以计算出需要哪些操作来更新被呈现在屏幕上的这个的应用程序。&lt;/p&gt;
&lt;p&gt;尽管 Fiber 是对 reconciler（协调器）的彻底重写，但是在 &lt;a href=&quot;https://facebook.github.io/react/docs/reconciliation.html&quot;&gt;React 文档中描述的&lt;/a&gt; 高级的算法大体相同。一些关键点就在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设不同的组件类型会生成完全不同的树。React 将不会尝试去 diff(比较)它们，而是完全替换旧的树。&lt;/li&gt;
&lt;li&gt;对于列表的 diffing 是使用键（keys）执行的。键应该是“稳定，可预测，并且独一无二的。”&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;协调与渲染&lt;/h2&gt;
&lt;p&gt;DOM 只是 React 可以渲染的渲染环境之一，其他主要目标是通过 React Native 的原生 iOS 和 Android 视图。 （这就是为什么“虚拟 DOM”有点用词不当。）&lt;/p&gt;
&lt;p&gt;React 可以支持如果多的目标平台的原因就是它被设计成 reconciliation 和 rendering 为相互独立的阶段。reconciler（协调器） 用来计算虚拟 DOM 树的哪些部分被改变了；renderer（渲染器）使用协调器计算出的这些信息对被渲染到屏幕上的内容进行实际的更新。&lt;/p&gt;
&lt;p&gt;这种分离意味着 React DOM 和 React Native 可以用它们自己的渲染器，同时共享由 React 核心提供的相同的协调器。&lt;/p&gt;
&lt;p&gt;Fiber 重新实现了协调器。它主要不涉及渲染，尽管渲染器也需要为支持（并利用）这个新的架构而做出改变。&lt;/p&gt;
&lt;h2&gt;调度（Scheduling）&lt;/h2&gt;
&lt;h3&gt;调度&lt;/h3&gt;
&lt;p&gt;判断什么时候该执行 work（这里的 work 是特定的概念，为了避免和通常概念中的工作混淆，译者选择不做翻译）的过程。&lt;/p&gt;
&lt;h3&gt;work&lt;/h3&gt;
&lt;p&gt;要被执行的任何计算。work 通常是一次更新的结果（例如&lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;React 的&lt;a href=&quot;https://facebook.github.io/react/contributing/design-principles.html#scheduling&quot;&gt;设计原则&lt;/a&gt;文档在这个主题上非常好，我就直接在这里引用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在其当前的实现中，React 递归地遍历虚拟 DOM 树并且在单个周期内调用整个被更新的树的 &lt;code class=&quot;language-text&quot;&gt;render&lt;/code&gt; 函数。然而在未来（React 16 及更高版本）它可能会延迟一些更新以避免掉帧。&lt;/p&gt;
&lt;p&gt;这是一个在 React 设计中普遍的主题。一些流行的库实现了“push（推）”方法，在数据可用时执行计算。然而 React 坚持采用 “pull（拉）”方法，即计算可以延迟到必要时才进行。&lt;/p&gt;
&lt;p&gt;React 不是一个通用的数据处理库。它是一个构建用户界面的库。我们认为，它在应用程序中的定位是独一无二的，可以知道哪些计算是相关的，哪些不是相关的。&lt;/p&gt;
&lt;p&gt;如果某些东西在画面以外，我们延迟与它相关的一切计算。如果数据到达得比帧率还要快，我们可以合并并且批量更新。我们可以提高来自用户界面的工作（例如一个按钮点击导致的动画）的优先级高于那些不那么重要的后台工作（例如渲染刚从网络中加载好的新的内容），以避免丢帧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关键点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在一个用户界面中，不需要每一次更新都立即应用；事实上，这么做可能很浪费，导致丢帧从而降低用户体验。&lt;/li&gt;
&lt;li&gt;不同类型的更新有不同的优先级——一个来自动画的更新需要比一个来自数据存储的更快地完成。&lt;/li&gt;
&lt;li&gt;基于推（push-based）的方法要求应用程序（你，程序员）来决定如何调度工作，而基于拉（pull-based）的方法允许框架（React）变得智能，并且为你做这些决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;React 目前（React 15 及更低版本）没有以一种重要的方式利用调度的优势；更新会立即重新渲染整个子树。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;现在我们已经准备深入了解 Fiber 的实现。下一节会比我们目前讨论的东西更有技术性。在继续前进之前，请确保你对前面的材料感到满意。&lt;/p&gt;
&lt;h2&gt;什么是 fiber？&lt;/h2&gt;
&lt;p&gt;我们打算讨论 React Fiber 架构的灵魂。Fibers 是比应用程序开发者们通常认为的更低级别的抽象。如果你发现你尝试去理解它时被刷下来了。不要感到失望。保持尝试并且最终会成功的。（当你最后明白了，请为如何提升这一节的内容提出建议。）&lt;/p&gt;
&lt;p&gt;开始吧!&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们已经确定 Fiber 的主要目标是使 React 能够充分利用调度。具体而言，我们需要能够去：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;暂停工作并且稍后可以返回到之前暂停的工作中。&lt;/li&gt;
&lt;li&gt;指定不同类型的工作的优先级。&lt;/li&gt;
&lt;li&gt;重用之前已完成的工作。&lt;/li&gt;
&lt;li&gt;如果不再需要，则终止工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了做到这些，我们首先需要一个将工作分解成单元的方式。从某种意义上来说，这就是 fiber。一个 fiber 代表一个工作单元。&lt;/p&gt;
&lt;p&gt;为了更进一步，让我们回到&lt;a href=&quot;https://github.com/reactjs/react-basic#transformation&quot;&gt;React 组件作为一个数据的函数&lt;/a&gt;的概念，其通常被表示为&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;v = f(d)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此，渲染 React 应用程序类似于调用一个函数，该函数的主体包含对其他函数的调用，依此类推。这个类比在思考 fiber 时很有用。&lt;/p&gt;
&lt;p&gt;通常我们使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Call_stack&quot;&gt;调用栈&lt;/a&gt;的方式来追踪程序的执行。当一个函数被执行，一个新的&lt;strong&gt;栈帧&lt;/strong&gt;会被添加到调用栈中。该栈帧代表代表该函数执行的工作。&lt;/p&gt;
&lt;p&gt;在处理 UI 时，问题是如果一次性执行太多的工作，可能会导致动画丢帧并且看起来很卡顿。更重要的是，如果这些工作被最近的更新所取代，那么其中有些工作可能是不必要的。这就是 UI 组件和函数比较割裂的地方。因为组件比一般的函数有更多的特定关注点。&lt;/p&gt;
&lt;p&gt;现代浏览器（和 React Native）实现了一些帮助定位这些额外的问题的 API：&lt;code class=&quot;language-text&quot;&gt;requestIdleCallback&lt;/code&gt;调度一个低优先级的函数在空闲期间被调用，&lt;code class=&quot;language-text&quot;&gt;requestAnimationFrame&lt;/code&gt;调度一个高优先级的函数在下一个动画帧之前被调用。问题在于，为了使用这些 API，你需要一个方式去将渲染工作（render work）分解为增量单元（？我的理解是，一个完整的工作拆分成多个单元，单元是可以累积的，完成了一个单元，整体完成进度就往前进）。如果只依赖调用栈，它会一直工作下去，直到栈被清空。&lt;/p&gt;
&lt;p&gt;如果我们可以自定义调用栈的行为来优化 UI 的渲染的话，那不是很好吗？如果我们可以随意中断调用栈并且手动操作堆栈帧，那不是很好吗？&lt;/p&gt;
&lt;p&gt;这就是 React Fiber 的目标。Fiber 是调用栈的重新实现，专门用于 React 组件。你可以将单个 fiber 看作是一个&lt;strong&gt;虚拟栈帧&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个调用栈的重新实现的好处就在于你可以&lt;a href=&quot;https://www.facebook.com/groups/2003630259862046/permalink/2054053404819731/&quot;&gt;保持栈帧在内存中&lt;/a&gt;并根据需要（以及任何时候）执行它们。这对实现我们的调度目标至关重要。&lt;/p&gt;
&lt;h2&gt;一个 fiber 的结构&lt;/h2&gt;
&lt;p&gt;注意：随着我们对实现细节的了解越来越具体，某些事情可能会发生变化的可能性也会增加。如果您发现任何错误或过时的信息，请提交 PR。&lt;/p&gt;
&lt;p&gt;具体来说，一个 fiber 是一个 JavaScript 对象，它包含关于一个组件信息的，它的输入和输出。&lt;/p&gt;
&lt;p&gt;一个 fiber 对应着一个栈帧，同时也对应一个组件的实例。以下是属于 fiber 的一些重要字段。（这个清单并不详尽。）&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;fiber 的 type 和 key 的作用与它们对 React 元素的作用相同。（事实上，当从一个元素创建 fiber 时，这两个字段是直接复制的。）&lt;br&gt;
一个 fiber 的 type 描述了与之对应的组件。对于组合组件（composite components）而言，type 可以是一个函数或者一个类组件本身。对于宿主组件（host components）（&lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;span&lt;/code&gt; 等）的 type 则是一个字符串。&lt;/p&gt;
&lt;p&gt;从概念上讲，type 是堆栈帧正在跟踪其执行的函数（如 v = f(d)）。&lt;/p&gt;
&lt;p&gt;与类型一起，在协调期间使用 key 来确定 fiber 是否可以重复使用。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;sibling&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这些字段指向其他的 fiber 节点，描述 fiber 的递归树形结构。&lt;/p&gt;
&lt;p&gt;child fiber 对应一个组件的 &lt;code class=&quot;language-text&quot;&gt;render&lt;/code&gt; 方法的返回值。所以在下面的例子中：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Child &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Parent&lt;/code&gt; 的 child fiber 对应与 &lt;code class=&quot;language-text&quot;&gt;Child&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;sibling（相邻，同辈） 字段说明了 &lt;code class=&quot;language-text&quot;&gt;render&lt;/code&gt; 方法返回多个子元素的情况（Fiber的一个新特性！）。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Parent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Child1 &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Child2 &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些 child fiber 形成一个以第一个 child render 为首节点的单向链表。所以在这个例子中，&lt;code class=&quot;language-text&quot;&gt;Parent&lt;/code&gt; 的 child 是 &lt;code class=&quot;language-text&quot;&gt;Child1&lt;/code&gt;，并且 &lt;code class=&quot;language-text&quot;&gt;Child1&lt;/code&gt; 的 sibling 是 &lt;code class=&quot;language-text&quot;&gt;Child2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;回到我们的函数类比，你可以把 child fiber 看成是一个尾部调用的函数。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;return fiber 是在处理完当前的 fiber 节点之后应该返回到的 fiber 节点。它相当于栈帧的返回地址。它也可以被认为是父 fiber 节点。&lt;/p&gt;
&lt;p&gt;如果一个 fiber 节点有多个子 fiber 节点，每个子 fiber 节点的 return fiber 是它们的父节点。所以在我们上一小节的例子中， &lt;code class=&quot;language-text&quot;&gt;Child1&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;Child2&lt;/code&gt; 的 return fiber 是 &lt;code class=&quot;language-text&quot;&gt;Parent&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pendingProps&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;meoizedProps&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从概念上而言，props 是一个函数的参数，一个 fiber 的 &lt;code class=&quot;language-text&quot;&gt;pendingProps&lt;/code&gt; 在他开始被执行时被设置，而 &lt;code class=&quot;language-text&quot;&gt;memoizedProps&lt;/code&gt; 是在执行即将结束时被设置。&lt;/p&gt;
&lt;p&gt;当输入的 &lt;code class=&quot;language-text&quot;&gt;pendingProps&lt;/code&gt; 和 &lt;code class=&quot;language-text&quot;&gt;memoizedProps&lt;/code&gt; 相等时，它表示 fiber 的上一个输出可能会被重用，从而防止不必要的工作。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;pendingWorkPriority&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个代表 fiber 工作的优先级的数字。&lt;a href=&quot;https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js&quot;&gt;ReactPriorityLevel&lt;/a&gt; 模块列出了不同的优先级和它们代表的含义。&lt;/p&gt;
&lt;p&gt;除了 &lt;code class=&quot;language-text&quot;&gt;NoWork&lt;/code&gt; 为 0之外，数字越大表示优先级越低。例如，你可以使用下面的函数来检测 fiber 的优先级是否和给定的级别一样高。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;matchesPriority&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;fiber&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; priority&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;pendingWorkPriority &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
           fiber&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;pendingWorkPriority &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; priority
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;这个函数只是一个例子；他并非 React Fiber 代码库中的一部分&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;调度器使用 priority 字段来搜索要被执行的下一个单元。这个算法将在未来的章节讨论。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt;（备份）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;flush&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
flush 一个 fiber 就是把它的输出渲染到屏幕上。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;work-in-progress&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
一个还未完成的 fiber，从概念上说，可以理解为一个还没有被返回的栈帧。&lt;/p&gt;
&lt;p&gt;在任何时刻，以一个组件的实例最多有两个 fiber 节点与之对应；一个是 current fiber，即被渲染到屏幕的 fiber，另一个是 work-in-progress fiber。&lt;/p&gt;
&lt;p&gt;currnet fiber 的 alternate 是 work-in-progress，而 work-in-progress 的 alternate 则是 current fiber。&lt;/p&gt;
&lt;p&gt;fiber 的 alternate 是通过一个叫做 &lt;code class=&quot;language-text&quot;&gt;cloneFiber&lt;/code&gt; 的函数按需地（lazily）被创建的，如果 fiber 的 alternate 存在的话，&lt;code class=&quot;language-text&quot;&gt;cloneFiber&lt;/code&gt; 会尝试重用它，而不是总是创建一个新的对象，从而最小化地分配。&lt;/p&gt;
&lt;p&gt;你应该把 &lt;code class=&quot;language-text&quot;&gt;alternate&lt;/code&gt; 字段看作是一个实现细节，但它在代码库中经常出现，所以在这里讨论它很有价值。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;output&lt;/code&gt;（输出）&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;宿主组件&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
React 应用程序的叶节点。它们特定于渲染环境（例如，在浏览器应用程序中，它们是 &lt;code class=&quot;language-text&quot;&gt;div&lt;/code&gt;、&lt;code class=&quot;language-text&quot;&gt;span&lt;/code&gt; 等）。在 JSX 中，它们使用小写的标签名字（tag names）表示。&lt;/p&gt;
&lt;p&gt;从概念上而言，一个 fiber 的 output 是一个函数的返回值。&lt;/p&gt;
&lt;p&gt;每个 fiber 最终都会有 output，但是 output 只会在叶节点被&lt;strong&gt;宿主组件&lt;/strong&gt;创建。然后将 output 沿树向上传输。&lt;/p&gt;
&lt;p&gt;output 就是最终给到渲染器（renderre）的东西，以至于渲染器可以 flush 这些更改到渲染环境中。而定义 output 如何被创建或被更新就是渲染器的事了。&lt;/p&gt;
&lt;h2&gt;未来的章节&lt;/h2&gt;
&lt;p&gt;到目前为止，这些就是全部的内容了，但是这篇文档还远远没有完成。未来的章节将讲述在更新过程的整个生命周期中所使用的算法。要涵盖的主题包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调度器如何找到下一个要被执行的工作单元。&lt;/li&gt;
&lt;li&gt;如何通过 fiber 树跟踪和传播优先级。&lt;/li&gt;
&lt;li&gt;调度器怎样知道什么时候暂停或恢复工作。&lt;/li&gt;
&lt;li&gt;工作如何被 flushed 并标记成完成。&lt;/li&gt;
&lt;li&gt;副作用（例如生命周期方法）如何工作。&lt;/li&gt;
&lt;li&gt;什么是协程（coroutine ）以及如何使用它来实现上下文和布局等功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;相关的视频&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://youtu.be/aV1271hd9ew&quot;&gt;What’s Next for React (ReactNext 2016)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=ZCuYPiUIONs&amp;#x26;t=471s&amp;#x26;ab_channel=FacebookDevelopers&quot;&gt;Lin Clark - A Cartoon Intro to Fiber - React Conf 2017&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[React 组件，元素，和实例]]></title><description><![CDATA[原文：React Components, Elements, and Instances – React Blog (reactjs.org) 作者：Dan Abramov 组件（components），实例（instances），和元素（elements…]]></description><link>https://blog-ak8.pages.dev/React 组件，元素，和实例/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/React 组件，元素，和实例/</guid><pubDate>Tue, 28 Sep 2021 13:30:00 GMT</pubDate><content:encoded>&lt;p&gt;原文：&lt;a href=&quot;https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html&quot;&gt;React Components, Elements, and Instances – React Blog (reactjs.org)&lt;/a&gt;&lt;br&gt;
作者：&lt;a href=&quot;https://twitter.com/dan_abramov&quot;&gt;Dan Abramov&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;组件（components），实例（instances），和元素（elements）之间的不同使得很多 React 新手困惑不已，为什么会有三种不同的术语来指代画在屏幕上的东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;管理实例（Managinng the Instances）&lt;/h2&gt;
&lt;p&gt;如果你刚接触到React，你可能之前只用过组件类和实例。例如你可能要通过创建一个类来声明一个 Button 组件。当这个应用运行时，可能有几个这些组件的实例在屏幕上，它们每个实例都有他们自己的属性（properties）和局部状态（local state）。这就是传统的面向对象用户界面编程。那为什么要引入元素（elements）呢？&lt;/p&gt;
&lt;p&gt;在传统的用户界面模型中，是由你（开发者）负责创建和销毁子组件实例。如果一个 Form 组件想要渲染一个 Button 组件，它（Form 组件）需要创建它的实例，并且手动保持它与任何新信息一致。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Form&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;TraditionalObjectOrientedView&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Read some data passed to the view&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; isSubmitted&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; buttonText &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;attrs&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;isSubmitted &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;button&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// Form is not yet submitted. Create the button!&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;button &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Button&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; buttonText&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        color&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;blue&apos;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;el&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;button&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;el&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;button&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// The button is visible. Update its text!&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;button&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;attrs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;children &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; buttonText&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;button&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isSubmitted &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;button&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// Form was submitted. Destroy the button!&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;el&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;removeChild&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;button&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;el&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;button&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;destroy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isSubmitted &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;message&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;// Form was submitted. Show the success message!&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;message &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Message&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; text&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Success!&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;el&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;appendChild&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;message&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;el&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是伪代码，但是当您使用像 Backbone 这样的库编写以面向对象的方式一致行为的复合 UI 代码时，这大致就是您的代码最终的样子。&lt;/p&gt;
&lt;p&gt;每个组件实例都必须保存对它的 DOM 节点的引用，和对子组件实例的引用。并且要在正确的时机创建，更新，和销毁它们。代码行数随着组件可能状态数的平方增长。而且这些父组件能够访问到它们的子组件的实例，这使得这些代码以后很难解耦。&lt;/p&gt;
&lt;p&gt;那么，React 有什么不同呢？&lt;/p&gt;
&lt;h2&gt;元素描述树（Elements Describe the Tree）&lt;/h2&gt;
&lt;p&gt;在 React 中，这就是元素（elements）来拯救的地方。一个元素是一个描述组件实例或DOM节点及其所需属性的普通对象。它仅包含有关组件类型（例如，按钮），其属性（例如，其颜色），以及其中任何子元素的信息。&lt;/p&gt;
&lt;p&gt;元素不是一个实际的的实例。他相当于是一个告诉 React 你想要在屏幕上看到什么东西的方式。你不能在元素上以调用任何方法。元素只是一个不可变的描述对象，其中有两个字段：类型（type:(string | ReactClass)） 和属性（props:Object）。&lt;/p&gt;
&lt;h2&gt;DOM 元素&lt;/h2&gt;
&lt;p&gt;当元素的 type 字段是一个字符串时，它代表一个标签名字为 type 的 DOM 节点，并且 它的 props 对应着它的 attributes。这就是 React 要渲染的东西，例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    className&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button button-blue&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;b&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;OK!&apos;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个元素就是把以下的 HTML 表示为普通对象的一种方式：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;button &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;button button-blue&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;b&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token constant&quot;&gt;OK&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;b&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;button&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意元素是可以被嵌套的。按照惯例，当我们想要创建一个元素树时，我们指定一个或多个子元素作为其包含元素的 children 属性。&lt;/p&gt;
&lt;p&gt;重点是子元素和父元素都只是描述而不是实际的实例。当你创建他们的时候他们不涉及任何在屏幕上的东西。你可以创造它们然后扔掉它们，这没什么大不了的。&lt;/p&gt;
&lt;p&gt;React 元素是容易遍历的，它不需要被解析，同时也比远比实际的 DOM 元素轻量得多——它们只是对象（object）！&lt;/p&gt;
&lt;h2&gt;组件元素（Component Elements）&lt;/h2&gt;
&lt;p&gt;然而，元素的类型也可以是对应于 React 组件的函数或类：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Button&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    color&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;blue&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;OK!&apos;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是 React 的核心思想&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;描述组件的元素也是一个元素，就像描述 DOM 节点的元素一样。它们可以相互嵌套和混合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此功能允许您将 DangerButton 组件定义为具有特定颜色属性值的 Button，而无需担心 Button 是否呈现为 DOM &amp;#x3C;button&gt;、&amp;#x3C;div&gt; 或其他完全不同的东西：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;DangerButton&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; children &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Button&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    color&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;red&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; children
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以在一个元素树中混合和匹配 DOM 和组件元素:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;DeleteAccount&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;div&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;p&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Are you sure?&apos;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; DangerButton&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Yep&apos;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Button&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        color&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;blue&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Cancel&apos;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者，如果你更喜欢 JSX：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;DeleteAccount&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Are you sure&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;p&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;DangerButton&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Yep&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;DangerButton&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
    &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;Button color&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;blue&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;Cancel&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;Button&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
  &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;div&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些混合和匹配帮助你保持组件之间相互解耦，因为它们可以完全通过组合来表达 is-a 和 has-a 关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Button是（is-a）有特定属性的 DOM &amp;#x3C;button&gt;。&lt;/li&gt;
&lt;li&gt;DangerButton 是（is-a）有特定属性的 Button。&lt;/li&gt;
&lt;li&gt;DeleteAccount 在 &amp;#x3C;div&gt; 中包含一个 Button 和一个DangerButton。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;组件封装元素树（Components Encapsulate Element Trees）&lt;/h2&gt;
&lt;p&gt;当 React 看到一个 type 为函数或者类的元素时，它知道询问该组件它渲染出（renders）什么元素，给定相应的 props。&lt;/p&gt;
&lt;p&gt;当它看到这个元素&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Button&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    color&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;blue&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;OK!&apos;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;React 将会“询问” （我的理解是调用 type）Button 它渲染什么元素，Button 将会返回这些元素：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    className&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button button-blue&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;b&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;OK!&apos;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;React 将会重复这个过程知道他知道在这个页面上的每一个元素的底层的DOM 标签元素。&lt;/p&gt;
&lt;p&gt;React 就像一个孩子问“Y 是什么”，你向他们解释每一个“X 是 Y”，直到他们弄清楚世界上的每一件小事。&lt;/p&gt;
&lt;p&gt;还记得上面那个 Form 例子吗？他可以用 React 写成下面这样。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Form&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; isSubmitted&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; buttonText &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isSubmitted&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// Form submitted! Return a message element.&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Message&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        text&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Success!&apos;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;// Form is still visible! Return a button element.&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Button&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; buttonText&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      color&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;blue&apos;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是这样！对于一个 React 组件（component），props 是输入，元素树（element tree）则是输出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被返回的元素树可以包含描述 DOM 节点的元素和描述其他组件的元素。它让你可以在不依赖于其内部 DOM 结构的情况下组合 UI 的独立部分。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们让 React 创造，更新，和销毁实例，我们用从组件返回的元素&lt;em&gt;描述&lt;/em&gt;它们，React 负责管理这些实例。&lt;/p&gt;
&lt;h2&gt;组件可以是类或者函数（Compoents Can Be Classes or Functions）&lt;/h2&gt;
&lt;p&gt;在上面的代码中，Form，Message，和 Button 是 React 组件，它们可以既可以写成函数，就像上面那样，也可以写成从 React.Component 继承的类。这三种声明组件的方式大多数情况下都是等价的。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 1) As a function of props&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;Button&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; children&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; color &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    className&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button button-&apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; color&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;b&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; children
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 2) Using the React.createClass() factory&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Button &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; children&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; color &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        className&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button button-&apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; color&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;b&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
          props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; children
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 3) As an ES6 class descending from React.Component&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Button&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Component&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; children&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; color &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;props&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        className&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button button-&apos;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; color&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
          type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;b&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
          props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; children
          &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当用类的方式定义一个组件时，它会比函数组件更强大一点。它可以存储局部状态并且可以在对应的 DOM 节点被创建或者被销毁时执行自定义的逻辑。&lt;/p&gt;
&lt;p&gt;一个函数组件虽然没有那么强大但是它更简单，而且表现得就像只有一个 render 方法的类组件一样。除非你需要只有在类组件中才有的功能，否则我们鼓励你使用函数组件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而，函数组件还是类组件，从根本上它们都是 React 的组件。它们将 props 作为它们的输入，而且返回元素（React 语境下的 elements，对要出现在屏幕上的 UI 的描述）作为它们的输出。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;自顶向下的协调（Top Down Reconciliation）&lt;/h2&gt;
&lt;p&gt;当你调用：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;ReactDOM&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Form&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    isSubmitted&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    buttonText&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;OK!&apos;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;root&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;React 将会问 Form 组件对于被给定的 Props 它会返回什么元素树。它将根据更简单的原语逐渐“完善”对组件树的理解：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// React: You told me this...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Form&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    isSubmitted&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    buttonText&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;OK!&apos;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// React: ...And Form told me this...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; Button&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;OK!&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    color&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;blue&apos;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// React: ...and Button told me this! I guess I&apos;m done.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    className&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;button button-blue&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      type&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;b&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
      props&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        children&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;OK!&apos;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是 React 调用协调器（reconciliation）的一部分过程，该过程在你调用 ReactDOM.render() 或者 setState() 时开始。在协调结束时，React 知道生成的 DOM 树，然后像 react-dom 或者 react-native 这样的渲染器&lt;br&gt;
（renderer）应用更新 DOM 节点（或者是特定平台的视图（view），在 React Native 的情况下）所需的最小更改集合。&lt;/p&gt;
&lt;p&gt;这种渐进式的提炼的过程也是 React 应用容易优化的原因。如果你的组件树中的一些部分对 React 有效地访问而言变得太大了的话，你可以告诉它：如果相关的 props 没有改变，请跳过这个提炼（refining）和差异（diffing）树的某些部分。如果 props 是不可变的话，计算 props 是否变化是非常快的。所以 React 和 不可变性（immutability）可以很好地协同工作，并且可以以最少的努力提供出色的优化。&lt;/p&gt;
&lt;p&gt;你可能已经注意到了这个博客文章讨论很多关于组件和元素的内容，却对实例（instances）谈论得不多。事实上，实例在 React 中的重要性要远低于大多数其他面向对象的 UI 框架。&lt;/p&gt;
&lt;p&gt;只有用类声明的组件才有实例，而且你绝对不会直接地创建它们：React 已经为你做了这些事情了。虽然父组件实例访问子组件实例的机制存在，但它们仅被用于紧急的动作（例如在一个字段上设置焦点），而且通常应该避免使用。&lt;/p&gt;
&lt;p&gt;React负责为每个类组件创建一个实例，所以你可以用面向对象的方法和本地状态来编写组件，但除此之外，实例在React的编程模型中并不十分重要，而是由React自己管理。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;一个元素（element）是一个普通对象，描述你想在屏幕上出现的 DOM 节点或其他组件。元素可以在它们的 props 中包含其他的元素。创建一个 React 元素是廉价的，一旦一个元素被创建，它就永远不会被突变（mutated）。&lt;/p&gt;
&lt;p&gt;一个组件可以用几种不同的方式被声明，它可能是一个有 render() 方法的类，或者，简单情况下，它可以以函数的方式被定义。无论是以哪种方式被定义，它都以 props 做为输入，并且返回一个元素树作为输出。&lt;/p&gt;
&lt;p&gt;当一个组件接收到一些 props 作为输入时，这是英文一个特定的父组件返回一个带有其类型（type 字段）和这些属性（props）的元素。这就是为什么人们说 props 在 React 单向流动：从父组件到子组件。&lt;/p&gt;
&lt;p&gt;一个实例（instance）就是你在编写类组件中被称之为 this 的东西，它对于存储局部状态和对声明周期时间做出反应很有用。&lt;/p&gt;
&lt;p&gt;函数组件完全没有实例。类组件有实例，但是你绝不需要直接创建一个组件的实例——React 负责这个。&lt;/p&gt;
&lt;p&gt;最后，要创建元素，使用 React.createElement()，JSX, 或则一个元素工厂帮助器。不要在真实的代码中以普通对象的形式写元素——你只需要知它们实际上是一个普通对象就行了。&lt;/p&gt;
&lt;h2&gt;延伸阅读&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://reactjs.org/blog/2014/10/14/introducing-react-elements.html&quot;&gt;Introducing React Elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://reactjs.org/blog/2015/02/24/streamlining-react-elements.html&quot;&gt;Streamling React Elemenets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://reactjs.org/docs/glossary.html&quot;&gt;React (Virtual) DOM Terminology&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[怎么用 OneDrive 做图床]]></title><description><![CDATA[博客文章大部分都是用 markdown…]]></description><link>https://blog-ak8.pages.dev/用 OneDrive 做图床/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/用 OneDrive 做图床/</guid><pubDate>Sat, 28 Aug 2021 16:00:00 GMT</pubDate><content:encoded>&lt;p&gt;博客文章大部分都是用 markdown 写作，文章中除了文字内容通常也有图片。&lt;/p&gt;
&lt;p&gt;可以将图片文件和网页代码放在一起，但是随着图片文件的增加会使得博客代码库体积变得越来越大，部署也越来越慢，也会增加托管服务器的流量和负担。&lt;/p&gt;
&lt;p&gt;还有一种选择是使用图床，图床是专门用来托管图片的，通过图床将图片文件上传到网络上，任何人只需要一个 uri 就可以访问这个图片。图床有一些已有的服务，比如微博图床，要么感觉不好管理，要么感觉不可靠，指不定什么时候就停止服务了。&lt;/p&gt;
&lt;p&gt;我日常使用的网盘是 OneDrive，OneDrive 是微软推出的网络存储服务，它直接内置于 Windows 系统中，除了常规的文件同步之外，照片的备份，管理也都可以完成。如果可以直接用 OneDrive 作为图床的话，就可以直接引用自己 OneDrive 中已有的图片，也方便管理。OneDrive 的文件可以共享，但是打开分享链接却是是通过网页版的 OneDrive 打开分享的文件，包括图片也是。再加上国内网络情况特殊，网页版的 OneDrive 是无法访问的。我去网上搜索了怎么用 OneDrive 做图床，结果还真有。具体操作就是使用 OneDrive 的文件嵌入功能。&lt;/p&gt;
&lt;p&gt;鼠标右键单击图片文件弹出的上下文菜单中鼠标单击单机“嵌入”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mP3CIubQk_IdR-GwjCAfB912mLQIk0dnxIQlG7uNJNLq9wZFOC51t_w86V9-OCFlEwwc-dw_KDCxnwv6J6V-nOMUiWnSsWu45K0vsrjcwGu6WT_0aXexUjI4_gORCnD-lAO3NSUmUTjjW6Rae076nFZe_mGp0ZR1gJUinXNjPrixvrbrajPbFZzwF8UXDnmJL?width=660&amp;#x26;height=493&amp;#x26;cropmode=none&quot; alt=&quot;OneDrive 的嵌入功能的入口&quot; title=&quot;OneDrive 的嵌入功能的入口&quot;&gt;&lt;/p&gt;
&lt;p&gt;网页右侧会弹出嵌入面板，可以直接生成图片 uri 链接，直接复制到要使用该图片的地方。还可以选择图片的尺寸。非常方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mX2VZpn5axL580EB_9Pqt8G7pELdVoTcn9rebc1iHDxf4_FWpa2burq3LL7vS5qTtOlqCATDIZ-n7Dt1lukOmwKsZGLKWSjnHqeL8tCdxq2gD6PRg1xmrH4P5GMuncs_VXaBRCQZJicHn8-OE1l39giGt9ipBSRnMLHji6A8yBH24s180vkqgvldAWzWcJf7r?width=660&amp;#x26;height=359&amp;#x26;cropmode=none&quot; alt=&quot;OneDrive 的嵌入功能的入口&quot; title=&quot;OneDrive 的嵌入功能的入口&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[我画了一个卡布达]]></title><description><![CDATA[卡布达 因为要给这个博客加一个 favicon，所以干脆自己画了一个。用的 figma 印着原图画的。用钢笔工具描。]]></description><link>https://blog-ak8.pages.dev/画了一个卡布达/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/画了一个卡布达/</guid><pubDate>Sat, 28 Aug 2021 13:27:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src=&quot;https://bl3301files.storage.live.com/y4mUTTBtMv7Q773x0PAL35vlYg_Ac3rWhQ1_96-9vsEUI7DnAedm529Il5CqtPPpWYU5Hbh5N9jpwkFpFVrOMZ6TPhnbaeodH3Z6t2qgowckOlw-BFXWrWgGBpI75yQ6d00K67WWfB7cGiBKQHRZywcTJgXF6_sifjMuhjRLBg8KImw4x3mtGJ2DU3kbTZWxNS8?width=256&amp;#x26;height=256&amp;#x26;cropmode=none&quot; alt=&quot;卡布达&quot; title=&quot;卡布达&quot;&gt;&lt;/p&gt;
&lt;p&gt;因为要给这个博客加一个 favicon，所以干脆自己画了一个。用的 figma 印着原图画的。用钢笔工具描。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[终于弄好了新的博客]]></title><description><![CDATA[这个博客用了传说中的 JAMStak，用了 Gatsby 构建，部署是使用 Cloudflare，都是之前都没有接触过的新技术。Gatsby 可以使用 React 的技术编码，构建高性能的网页。Cloudflare 可以托管静态站点，也可以提供站点 CDN…]]></description><link>https://blog-ak8.pages.dev/终于弄好了新的博客/</link><guid isPermaLink="false">https://blog-ak8.pages.dev/终于弄好了新的博客/</guid><pubDate>Sat, 28 Aug 2021 12:00:00 GMT</pubDate><content:encoded>&lt;p&gt;这个博客用了传说中的 JAMStak，用了 Gatsby 构建，部署是使用 Cloudflare，都是之前都没有接触过的新技术。Gatsby 可以使用 React 的技术编码，构建高性能的网页。Cloudflare 可以托管静态站点，也可以提供站点 CDN 加速，而且基本功能可以免费使用。&lt;/p&gt;
&lt;p&gt;Github 和 Cloudflare pages 集成，一旦被配置的 GitHub 仓库的特定分支有新提交，Cloudflare 会自动拉取代码然后构建，并将构建后的代码部署到 Cloudflare 的服务器和 CDN 上。&lt;/p&gt;
&lt;p&gt;测试一下 github pages&lt;/p&gt;</content:encoded></item></channel></rss>