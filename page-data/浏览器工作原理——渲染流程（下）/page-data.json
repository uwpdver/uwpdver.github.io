{"componentChunkName":"component---src-templates-blog-post-js","path":"/浏览器工作原理——渲染流程（下）/","result":{"data":{"site":{"siteMetadata":{"title":"要没时间了的博客"}},"markdownRemark":{"id":"b1053f09-7f4e-5171-9746-4e5aa6bf376a","excerpt":"总结 分层：将页面分成多个图层，每个图层可以独立栅格化。 绘制：为每个图层生成对应绘制操作列表，每个绘制操作都代表一个绘图的步骤。 分块：将图层分成若干图块，交给 GPU…","html":"<h2>总结</h2>\n<ol>\n<li>分层：将页面分成多个图层，每个图层可以独立栅格化。</li>\n<li>绘制：为每个图层生成对应绘制操作列表，每个绘制操作都代表一个绘图的步骤。</li>\n<li>分块：将图层分成若干图块，交给 GPU 进程栅格化。</li>\n<li>栅格化：栅格器由线程池，中的线程根据图块的绘制操作列表，将图块转化成位图数据。</li>\n<li>合成和显示：合成多个图层到内存中，然后显示在屏幕上。</li>\n</ol>\n<h2>分层（layer）</h2>\n<p>一个图层是页面的一部分，它可以独立于其他层被变形和栅格化。每个节点都属于一个图层，没有特别指定层级的节点属于父节点的所在的图层。</p>\n<h3>单独提升为一个图层的条件</h3>\n<ol>\n<li>\n<p>拥有堆叠上下文属性的元素</p>\n<ul>\n<li>\n<p>文档的根元素（<code class=\"language-text\">&lt;html></code>）；</p>\n</li>\n<li>\n<p>position     属性的值为 absolute（绝对定位）或     relative（相对定位）且 z-index 属性的值不为 auto；</p>\n</li>\n<li>\n<p>position 值为     fixed（固定定位）或 sticky（粘滞定位）的元素（沾滞定位适配所有移动设备上的浏览器，但老的桌面浏览器不支持）；</p>\n</li>\n<li>\n<p>flex (flexbox) 容器的子元素，且 z-index 值不为 auto；</p>\n</li>\n<li>\n<p>grid (grid) 容器的子元素，且 z-index 值不为 auto；</p>\n</li>\n<li>\n<p>opacity 属性值小于 1     的元素；</p>\n</li>\n<li>\n<p>mix-blend-mode     属性值不为 normal 的元素；</p>\n</li>\n<li>\n<p>以下任意属性值不为 none 的元素：</p>\n</li>\n<li>\n<ul>\n<li>transform</li>\n<li>filter</li>\n<li>perspective</li>\n<li>clip-path</li>\n<li>mask / mask-image / mask-border</li>\n<li>isolation 属性值为 isolate 的元素；</li>\n<li>-webkit-overflow-scrolling 属性值为 touch 的元素；</li>\n<li>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；</li>\n<li>contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>需要被裁切的元素</p>\n<p>当一个元素的内容尺寸超过了元素本身的尺寸，并且指定了 overflow 属性，这时候就产生了裁剪。渲染引擎会把内容的一部分显示在元素区域内。</p>\n<p>出现这种裁剪情况的时候，渲染引擎会为内容元素单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。</p>\n</li>\n</ol>\n<h2>绘制（paint）</h2>\n<p>绘制过程中为每个图层构建一个<strong>绘制操作（paint ops）列表</strong>。绘制的顺序是元素的堆叠顺序而不是 DOM 顺序，绘制会分成好几个阶段（backgrounds->floats->foregrounds->outlines->…），每个阶段都是对堆叠上下文的单独遍历。</p>\n<p><img src=\"https://bl3301files.storage.live.com/y4muxL_Nkw6OlPHZshXlEJnnlsue3YpuHpmem2wATf2X83kS_E4uZ6xIVxlJgTL3cZyk1r0PUQTJ2agNg9Mx5mGZ8_3AKgKAC_wgfluAqoj2MGFYQRq6-VUA376h5ZYkO49JQlH9bkDXJvKrgLPqBP2YU4vm3YcM1nweZYq-x7Ce07zIJpelOvWWcvyZvDBW38p?width=1151&#x26;height=527&#x26;cropmode=none\" alt=\"绘制操作列表\" title=\"从 DOM树 到布局树再到绘制操作的流程\"></p>\n<p><img src=\"https://bl3301files.storage.live.com/y4mh7Z8bzs3f7LEs1joBMW2lxKrfyTvG1jLsK22Oe7DnoFWowayA9fYuxBXFM6U-oIBOjK-1_HvvaJ-TdsT--BeUv8syInTD4VgAVaphXkJn7Sh1OYIMMqqcbgTasiyNAaazfrVm1uakCLPH7MHd0QentyHmXEFOoFOs0q5S3eqrLXN3SRcncC22TlOqMzVPW7P?width=1151&#x26;height=526&#x26;cropmode=none\" alt=\"绘制例子\" title=\"绘制操作详细示例\"></p>\n<h2>栅格化（raster）</h2>\n<p>栅格化将绘制阶段构建的绘制操作列表转换成位图。</p>\n<h2>分块（tilling）</h2>\n<p>绘制操作列表准备好之后，主线程会将图层的绘制操作列表<strong>提交</strong>给合成器线程。</p>\n<p>图层可能会很大，这样的话栅格化整个图层耗费的代价是十分昂贵的，而且对那些图层中不可见的部分栅格化是完全没必要的。所以合成器线程会将图层分成若干个<strong>图块</strong>（tiles：瓷砖，瓦片）。</p>\n<h3>栅格化是多线程的</h3>\n<p>图块是栅格化的单元，被分块的若干图块会被一个栅格器线程池中的线程渲染。<strong>越靠近视口的图块越优先被栅格化</strong>。因为渲染进程是运行在沙盒中，所以无法直接执行操作系统调用。经过绘制后得到的数据被送到 GPU 进程栅格化，所以<strong>栅格器是运行在 GPU 线程中的</strong>。</p>\n<p><img src=\"https://bl3301files.storage.live.com/y4mIu1AfxShFTYRtq9511U9ICMTRgyO5HF8MzBhsl1VllEajRW8fgd5d09tL_dsbwtdyPQmn2WTOLj2d46Xsc8JV4dSVhQIKQA-ZK3tlrxkjR_nacACU6TTeQTboYIHBgZZL-wy6uzOHOZbBSRoD9GiMmcDj-csuTM5gGcy72QrCWRyxOrI4o_3Ki3Jc-03F72f?width=1151&#x26;height=531&#x26;cropmode=none\" alt=\"分块和栅格器线程池\" title=\"分块和栅格器线程池\"></p>\n<p>栅格化之后生成的位图被存储在内存中，通常是由 OpenGL 纹理对象引用的 GPU 内存。GPU 还可以运行生成位图的命令（“加速栅格化”）。</p>\n<h2>合成与显示</h2>\n<p>图块被栅格化之后，合成器线程会生成一个 DrawQuads 命令，这个命令代表在屏幕上一个特定位置画出图块。这个命令还没有真正地转化成屏幕上的像素，而是对应在内存中的表示。最后再将内存中的数据显示在屏幕上（显示这个步骤很模糊，课程中也是一笔带过）。</p>\n<h2>回顾</h2>\n<p><img src=\"https://bl3301files.storage.live.com/y4mq3n5KbzaoK7vSk-oJXoHis8oTLw0ac-KhD2JRCFQC-VBGoJVsTfpPFZEQ7hUmuCLvPnc6v-3V3JDDcR7TNvohezCTXdFxSW8baS2yMGyc7gQBM7O8T1MpbGrbPQDqJpvOnHvfz-BxBQARjhLxBFzvG-jll_PF8FvAeoJCxxLv2lk5NDX_YtV637dvhmR-GXw?width=1150&#x26;height=627&#x26;cropmode=none\" alt=\"从 HTML 到像素的总流程图\" title=\"从 HTML 到像素的总流程图\"></p>\n<h2>相关阅读</h2>\n<ul>\n<li><a href=\"https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_29\">Life of a Pixel（PPT）</a></li>\n</ul>","tableOfContents":"<ul>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n<li><a href=\"#%E5%88%86%E5%B1%82layer\">分层（layer）</a></li>\n<li><a href=\"#%E7%BB%98%E5%88%B6paint\">绘制（paint）</a></li>\n<li><a href=\"#%E6%A0%85%E6%A0%BC%E5%8C%96raster\">栅格化（raster）</a></li>\n<li><a href=\"#%E5%88%86%E5%9D%97tilling\">分块（tilling）</a></li>\n<li><a href=\"#%E5%90%88%E6%88%90%E4%B8%8E%E6%98%BE%E7%A4%BA\">合成与显示</a></li>\n<li><a href=\"#%E5%9B%9E%E9%A1%BE\">回顾</a></li>\n<li><a href=\"#%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB\">相关阅读</a></li>\n</ul>","frontmatter":{"title":"浏览器工作原理——渲染流程（下）","date":"2021年10月22日","description":"《浏览器工作原理》专栏第六节的学习笔记，本篇是渲染流程章节的下篇，主要是讲解从分层到合成的过程，涉及到了更底层的概念。","tags":["笔记","浏览器","网页渲染","浏览器工作原理"]}},"previous":{"fields":{"slug":"/浏览器工作原理——渲染流程（上）/"},"frontmatter":{"title":"浏览器工作原理——渲染流程（上）"}},"next":{"fields":{"slug":"/浏览器工作原理——变量提升/"},"frontmatter":{"title":"浏览器工作原理——变量提升"}}},"pageContext":{"id":"b1053f09-7f4e-5171-9746-4e5aa6bf376a","previousPostId":"c324e77e-1ed3-5fbf-8e06-acdf05ac0267","nextPostId":"0aac13dc-a8b3-5747-8558-97a1bac916bb"}},"staticQueryHashes":["2792646216","2841359383"]}