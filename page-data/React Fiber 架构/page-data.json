{"componentChunkName":"component---src-templates-blog-post-js","path":"/React Fiber 架构/","result":{"data":{"site":{"siteMetadata":{"title":"要没时间了的博客"}},"markdownRemark":{"id":"a4673d0f-0c84-5623-a2a3-dc751ff864d0","excerpt":"原文：React Fiber Architecture 作者：acdlite React Fiber 是一个正在进行的 React 的核心算法的重新实现。 React Fiber…","html":"<p>原文：<a href=\"https://github.com/acdlite/react-fiber-architecture\">React Fiber Architecture</a><br>\n作者：<a href=\"https://twitter.com/acdlite\">acdlite</a></p>\n<p>React Fiber 是一个正在进行的 React 的核心算法的重新实现。</p>\n<p>React Fiber 的目标就是增强对动画，布局，和手势等领域的适应性。它的头号特性就是<strong>增量渲染</strong>：一种将渲染工作拆分成多个更小的部分并且把这些部分的工作分摊到多个帧上的能力。</p>\n<p>其他的关键特性包括暂停的能力，终止的能力，当新的更新到来时重用工作的能力；为不同类型的更新指定优先级的能力；还有新的并发原语（concurrency primitives）。</p>\n<h2>关于这个文档</h2>\n<p>Fiber 引入了几个新的概念，这些概念光看代码很难完全理解。这个文档开始是我在追随 Fiber 在 React 项目中的实现的过程中做的笔记的集合，随着它的增长，我意识到它可能也是一个对别人很有帮助的资源。</p>\n<p>我将尝试用尽可能简朴的语言，并通过解释定义关键术语来避免行话，如果可能，我也会大量连接到外部的资源。</p>\n<p>请注意，我并不是 React 团队的成员，而且没有任何权威的发言权。<strong>这不是一个官方文档</strong>。我已经要求 React 团队的成员审查过它的准确性。</p>\n<p>这也是一个正在施工中的工作，<strong>Fiber 是一个正在进行中的项目，在完成之前可能会进行重大的重构</strong>。此外，我还在尝试在这里记录它的设计。我非常欢迎提出改进和建议。</p>\n<p>我的目标是在读完这篇文档之后，你将对 Fiber 有足够的了解，以便在它的实现过程中进行跟进，最终能够为 React 做出贡献。</p>\n<h2>阅读之前的准备</h2>\n<p>我强烈建议你在继续阅读之前熟悉下面这些资源:</p>\n<ul>\n<li><a href=\"https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html\">React 组件，元素，和实例</a>-“组件是一个经常被重载的术语，牢牢掌握这些术语至关重要”</li>\n<li><a href=\"https://facebook.github.io/react/docs/reconciliation.html\">Reconciliation</a>-一个对 React 的协调算法的高级的描述。</li>\n<li><a href=\"https://github.com/reactjs/react-basic\">React 基本理论概念</a>-对 React 的概念模型的描述，不用理解具体的实现。其中一些内容在初读时可能没有意义，没有关系，随着时间的推移，它将变得更有意义。</li>\n</ul>\n<h2>回顾</h2>\n<h2>什么是协调（reconciliation）</h2>\n<h3>协调（reconciliation）</h3>\n<p>React 用来将一棵树和另外一棵树进行比较，以确定哪些部分需要被改变的算法。</p>\n<h3>更新</h3>\n<p>用来渲染 React 应用的数据的一次改变，通常是由 ‘setState’ 引起的。最终导致重新渲染（re-render）。</p>\n<p>React API 的中心思想就是将更新看作是导致整个应用程序重新渲染。这允许开发者以声明的方式进行推理，而不是担心如何有效地将应用从任何一个特定的状态转换到另一个特定的状态（A 到 B，B 到 C，C 到 A，等等）。</p>\n<p>实际上在每次更改后都重新渲染整个应用程序仅适用于最琐碎的应用程序；在一个真正的应用程序中，这种做法的性能成本太高了。React 进行了优化，可以在保持出色性能的同时创建整个应用程序重新渲染的外观。这些优化中的大部分是一个被称之为 <strong>reconciliation（以下称为协调）</strong> 的过程的一部分。</p>\n<p>协调是通常被理解为 “虚拟 DOM（virtual DOM）”背后的算法。一个高级描述像这样：当你渲染一个 React 应用程序，就会有一棵由多个节点组成，用来描述这个应用程序的树被生成，并且被保存在内存中。然后，这棵树将被刷新到渲染环境中——例如，在浏览器应用程序的情况下，它被转换成一系列 DOM 操作。每当应用程序更新（通常是通过 <code class=\"language-text\">setState</code>）时，就会生成一棵新的树。这棵新的树和之前的那棵树进行比较，以计算出需要哪些操作来更新被呈现在屏幕上的这个的应用程序。</p>\n<p>尽管 Fiber 是对 reconciler（协调器）的彻底重写，但是在 <a href=\"https://facebook.github.io/react/docs/reconciliation.html\">React 文档中描述的</a> 高级的算法大体相同。一些关键点就在于：</p>\n<ul>\n<li>假设不同的组件类型会生成完全不同的树。React 将不会尝试去 diff(比较)它们，而是完全替换旧的树。</li>\n<li>对于列表的 diffing 是使用键（keys）执行的。键应该是“稳定，可预测，并且独一无二的。”</li>\n</ul>\n<h2>协调与渲染</h2>\n<p>DOM 只是 React 可以渲染的渲染环境之一，其他主要目标是通过 React Native 的原生 iOS 和 Android 视图。 （这就是为什么“虚拟 DOM”有点用词不当。）</p>\n<p>React 可以支持如果多的目标平台的原因就是它被设计成 reconciliation 和 rendering 为相互独立的阶段。reconciler（协调器） 用来计算虚拟 DOM 树的哪些部分被改变了；renderer（渲染器）使用协调器计算出的这些信息对被渲染到屏幕上的内容进行实际的更新。</p>\n<p>这种分离意味着 React DOM 和 React Native 可以用它们自己的渲染器，同时共享由 React 核心提供的相同的协调器。</p>\n<p>Fiber 重新实现了协调器。它主要不涉及渲染，尽管渲染器也需要为支持（并利用）这个新的架构而做出改变。</p>\n<h2>调度（Scheduling）</h2>\n<h3>调度</h3>\n<p>判断什么时候该执行 work（这里的 work 是特定的概念，为了避免和通常概念中的工作混淆，译者选择不做翻译）的过程。</p>\n<h3>work</h3>\n<p>要被执行的任何计算。work 通常是一次更新的结果（例如<code class=\"language-text\">setState</code>）</p>\n<p>React 的<a href=\"https://facebook.github.io/react/contributing/design-principles.html#scheduling\">设计原则</a>文档在这个主题上非常好，我就直接在这里引用：</p>\n<blockquote>\n<p>在其当前的实现中，React 递归地遍历虚拟 DOM 树并且在单个周期内调用整个被更新的树的 <code class=\"language-text\">render</code> 函数。然而在未来（React 16 及更高版本）它可能会延迟一些更新以避免掉帧。</p>\n<p>这是一个在 React 设计中普遍的主题。一些流行的库实现了“push（推）”方法，在数据可用时执行计算。然而 React 坚持采用 “pull（拉）”方法，即计算可以延迟到必要时才进行。</p>\n<p>React 不是一个通用的数据处理库。它是一个构建用户界面的库。我们认为，它在应用程序中的定位是独一无二的，可以知道哪些计算是相关的，哪些不是相关的。</p>\n<p>如果某些东西在画面以外，我们延迟与它相关的一切计算。如果数据到达得比帧率还要快，我们可以合并并且批量更新。我们可以提高来自用户界面的工作（例如一个按钮点击导致的动画）的优先级高于那些不那么重要的后台工作（例如渲染刚从网络中加载好的新的内容），以避免丢帧。</p>\n</blockquote>\n<p>关键点在于：</p>\n<ul>\n<li>在一个用户界面中，不需要每一次更新都立即应用；事实上，这么做可能很浪费，导致丢帧从而降低用户体验。</li>\n<li>不同类型的更新有不同的优先级——一个来自动画的更新需要比一个来自数据存储的更快地完成。</li>\n<li>基于推（push-based）的方法要求应用程序（你，程序员）来决定如何调度工作，而基于拉（pull-based）的方法允许框架（React）变得智能，并且为你做这些决定。</li>\n</ul>\n<p>React 目前（React 15 及更低版本）没有以一种重要的方式利用调度的优势；更新会立即重新渲染整个子树。</p>\n<hr>\n<p>现在我们已经准备深入了解 Fiber 的实现。下一节会比我们目前讨论的东西更有技术性。在继续前进之前，请确保你对前面的材料感到满意。</p>\n<h2>什么是 fiber？</h2>\n<p>我们打算讨论 React Fiber 架构的灵魂。Fibers 是比应用程序开发者们通常认为的更低级别的抽象。如果你发现你尝试去理解它时被刷下来了。不要感到失望。保持尝试并且最终会成功的。（当你最后明白了，请为如何提升这一节的内容提出建议。）</p>\n<p>开始吧!</p>\n<hr>\n<p>我们已经确定 Fiber 的主要目标是使 React 能够充分利用调度。具体而言，我们需要能够去：</p>\n<ul>\n<li>暂停工作并且稍后可以返回到之前暂停的工作中。</li>\n<li>指定不同类型的工作的优先级。</li>\n<li>重用之前已完成的工作。</li>\n<li>如果不再需要，则终止工作。</li>\n</ul>\n<p>为了做到这些，我们首先需要一个将工作分解成单元的方式。从某种意义上来说，这就是 fiber。一个 fiber 代表一个工作单元。</p>\n<p>为了更进一步，让我们回到<a href=\"https://github.com/reactjs/react-basic#transformation\">React 组件作为一个数据的函数</a>的概念，其通常被表示为</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">v = f(d)</code></pre></div>\n<p>因此，渲染 React 应用程序类似于调用一个函数，该函数的主体包含对其他函数的调用，依此类推。这个类比在思考 fiber 时很有用。</p>\n<p>通常我们使用<a href=\"https://en.wikipedia.org/wiki/Call_stack\">调用栈</a>的方式来追踪程序的执行。当一个函数被执行，一个新的<strong>栈帧</strong>会被添加到调用栈中。该栈帧代表代表该函数执行的工作。</p>\n<p>在处理 UI 时，问题是如果一次性执行太多的工作，可能会导致动画丢帧并且看起来很卡顿。更重要的是，如果这些工作被最近的更新所取代，那么其中有些工作可能是不必要的。这就是 UI 组件和函数比较割裂的地方。因为组件比一般的函数有更多的特定关注点。</p>\n<p>现代浏览器（和 React Native）实现了一些帮助定位这些额外的问题的 API：<code class=\"language-text\">requestIdleCallback</code>调度一个低优先级的函数在空闲期间被调用，<code class=\"language-text\">requestAnimationFrame</code>调度一个高优先级的函数在下一个动画帧之前被调用。问题在于，为了使用这些 API，你需要一个方式去将渲染工作（render work）分解为增量单元（？我的理解是，一个完整的工作拆分成多个单元，单元是可以累积的，完成了一个单元，整体完成进度就往前进）。如果只依赖调用栈，它会一直工作下去，直到栈被清空。</p>\n<p>如果我们可以自定义调用栈的行为来优化 UI 的渲染的话，那不是很好吗？如果我们可以随意中断调用栈并且手动操作堆栈帧，那不是很好吗？</p>\n<p>这就是 React Fiber 的目标。Fiber 是调用栈的重新实现，专门用于 React 组件。你可以将单个 fiber 看作是一个<strong>虚拟栈帧</strong>。</p>\n<p>这个调用栈的重新实现的好处就在于你可以<a href=\"https://www.facebook.com/groups/2003630259862046/permalink/2054053404819731/\">保持栈帧在内存中</a>并根据需要（以及任何时候）执行它们。这对实现我们的调度目标至关重要。</p>\n<h2>一个 fiber 的结构</h2>\n<p>注意：随着我们对实现细节的了解越来越具体，某些事情可能会发生变化的可能性也会增加。如果您发现任何错误或过时的信息，请提交 PR。</p>\n<p>具体来说，一个 fiber 是一个 JavaScript 对象，它包含关于一个组件信息的，它的输入和输出。</p>\n<p>一个 fiber 对应着一个栈帧，同时也对应一个组件的实例。以下是属于 fiber 的一些重要字段。（这个清单并不详尽。）</p>\n<p><code class=\"language-text\">type</code> 和 <code class=\"language-text\">key</code></p>\n<p>fiber 的 type 和 key 的作用与它们对 React 元素的作用相同。（事实上，当从一个元素创建 fiber 时，这两个字段是直接复制的。）<br>\n一个 fiber 的 type 描述了与之对应的组件。对于组合组件（composite components）而言，type 可以是一个函数或者一个类组件本身。对于宿主组件（host components）（<code class=\"language-text\">div</code>，<code class=\"language-text\">span</code> 等）的 type 则是一个字符串。</p>\n<p>从概念上讲，type 是堆栈帧正在跟踪其执行的函数（如 v = f(d)）。</p>\n<p>与类型一起，在协调期间使用 key 来确定 fiber 是否可以重复使用。</p>\n<p><code class=\"language-text\">child</code> 和 <code class=\"language-text\">sibling</code></p>\n<p>这些字段指向其他的 fiber 节点，描述 fiber 的递归树形结构。</p>\n<p>child fiber 对应一个组件的 <code class=\"language-text\">render</code> 方法的返回值。所以在下面的例子中：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>Child <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">Parent</code> 的 child fiber 对应与 <code class=\"language-text\">Child</code>。</p>\n<p>sibling（相邻，同辈） 字段说明了 <code class=\"language-text\">render</code> 方法返回多个子元素的情况（Fiber的一个新特性！）。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">&lt;</span>Child1 <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&lt;</span>Child2 <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这些 child fiber 形成一个以第一个 child render 为首节点的单向链表。所以在这个例子中，<code class=\"language-text\">Parent</code> 的 child 是 <code class=\"language-text\">Child1</code>，并且 <code class=\"language-text\">Child1</code> 的 sibling 是 <code class=\"language-text\">Child2</code>。</p>\n<p>回到我们的函数类比，你可以把 child fiber 看成是一个尾部调用的函数。</p>\n<p><code class=\"language-text\">return</code></p>\n<p>return fiber 是在处理完当前的 fiber 节点之后应该返回到的 fiber 节点。它相当于栈帧的返回地址。它也可以被认为是父 fiber 节点。</p>\n<p>如果一个 fiber 节点有多个子 fiber 节点，每个子 fiber 节点的 return fiber 是它们的父节点。所以在我们上一小节的例子中， <code class=\"language-text\">Child1</code> 和 <code class=\"language-text\">Child2</code> 的 return fiber 是 <code class=\"language-text\">Parent</code>。</p>\n<p><code class=\"language-text\">pendingProps</code> 和 <code class=\"language-text\">meoizedProps</code></p>\n<p>从概念上而言，props 是一个函数的参数，一个 fiber 的 <code class=\"language-text\">pendingProps</code> 在他开始被执行时被设置，而 <code class=\"language-text\">memoizedProps</code> 是在执行即将结束时被设置。</p>\n<p>当输入的 <code class=\"language-text\">pendingProps</code> 和 <code class=\"language-text\">memoizedProps</code> 相等时，它表示 fiber 的上一个输出可能会被重用，从而防止不必要的工作。</p>\n<p><code class=\"language-text\">pendingWorkPriority</code></p>\n<p>一个代表 fiber 工作的优先级的数字。<a href=\"https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js\">ReactPriorityLevel</a> 模块列出了不同的优先级和它们代表的含义。</p>\n<p>除了 <code class=\"language-text\">NoWork</code> 为 0之外，数字越大表示优先级越低。例如，你可以使用下面的函数来检测 fiber 的优先级是否和给定的级别一样高。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">matchesPriority</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">fiber<span class=\"token punctuation\">,</span> priority</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> fiber<span class=\"token punctuation\">.</span>pendingWorkPriority <span class=\"token operator\">!==</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span>\n           fiber<span class=\"token punctuation\">.</span>pendingWorkPriority <span class=\"token operator\">&lt;=</span> priority\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><em>这个函数只是一个例子；他并非 React Fiber 代码库中的一部分</em></p>\n<p>调度器使用 priority 字段来搜索要被执行的下一个单元。这个算法将在未来的章节讨论。</p>\n<p><code class=\"language-text\">alternate</code>（备份）</p>\n<p><em><strong>flush</strong></em><br>\nflush 一个 fiber 就是把它的输出渲染到屏幕上。</p>\n<p><em><strong>work-in-progress</strong></em><br>\n一个还未完成的 fiber，从概念上说，可以理解为一个还没有被返回的栈帧。</p>\n<p>在任何时刻，以一个组件的实例最多有两个 fiber 节点与之对应；一个是 current fiber，即被渲染到屏幕的 fiber，另一个是 work-in-progress fiber。</p>\n<p>currnet fiber 的 alternate 是 work-in-progress，而 work-in-progress 的 alternate 则是 current fiber。</p>\n<p>fiber 的 alternate 是通过一个叫做 <code class=\"language-text\">cloneFiber</code> 的函数按需地（lazily）被创建的，如果 fiber 的 alternate 存在的话，<code class=\"language-text\">cloneFiber</code> 会尝试重用它，而不是总是创建一个新的对象，从而最小化地分配。</p>\n<p>你应该把 <code class=\"language-text\">alternate</code> 字段看作是一个实现细节，但它在代码库中经常出现，所以在这里讨论它很有价值。</p>\n<p><code class=\"language-text\">output</code>（输出）</p>\n<p><em><strong>宿主组件</strong></em><br>\nReact 应用程序的叶节点。它们特定于渲染环境（例如，在浏览器应用程序中，它们是 <code class=\"language-text\">div</code>、<code class=\"language-text\">span</code> 等）。在 JSX 中，它们使用小写的标签名字（tag names）表示。</p>\n<p>从概念上而言，一个 fiber 的 output 是一个函数的返回值。</p>\n<p>每个 fiber 最终都会有 output，但是 output 只会在叶节点被<strong>宿主组件</strong>创建。然后将 output 沿树向上传输。</p>\n<p>output 就是最终给到渲染器（renderre）的东西，以至于渲染器可以 flush 这些更改到渲染环境中。而定义 output 如何被创建或被更新就是渲染器的事了。</p>\n<h2>未来的章节</h2>\n<p>到目前为止，这些就是全部的内容了，但是这篇文档还远远没有完成。未来的章节将讲述在更新过程的整个生命周期中所使用的算法。要涵盖的主题包括：</p>\n<ul>\n<li>调度器如何找到下一个要被执行的工作单元。</li>\n<li>如何通过 fiber 树跟踪和传播优先级。</li>\n<li>调度器怎样知道什么时候暂停或恢复工作。</li>\n<li>工作如何被 flushed 并标记成完成。</li>\n<li>副作用（例如生命周期方法）如何工作。</li>\n<li>什么是协程（coroutine ）以及如何使用它来实现上下文和布局等功能。</li>\n</ul>\n<h2>相关的视频</h2>\n<ul>\n<li><a href=\"https://youtu.be/aV1271hd9ew\">What’s Next for React (ReactNext 2016)</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs&#x26;t=471s&#x26;ab_channel=FacebookDevelopers\">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017</a></li>\n</ul>","tableOfContents":"<ul>\n<li><a href=\"#%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%AA%E6%96%87%E6%A1%A3\">关于这个文档</a></li>\n<li><a href=\"#%E9%98%85%E8%AF%BB%E4%B9%8B%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87\">阅读之前的准备</a></li>\n<li><a href=\"#%E5%9B%9E%E9%A1%BE\">回顾</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E8%B0%83reconciliation\">什么是协调（reconciliation）</a></li>\n<li><a href=\"#%E5%8D%8F%E8%B0%83%E4%B8%8E%E6%B8%B2%E6%9F%93\">协调与渲染</a></li>\n<li><a href=\"#%E8%B0%83%E5%BA%A6scheduling\">调度（Scheduling）</a></li>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF-fiber\">什么是 fiber？</a></li>\n<li><a href=\"#%E4%B8%80%E4%B8%AA-fiber-%E7%9A%84%E7%BB%93%E6%9E%84\">一个 fiber 的结构</a></li>\n<li><a href=\"#%E6%9C%AA%E6%9D%A5%E7%9A%84%E7%AB%A0%E8%8A%82\">未来的章节</a></li>\n<li><a href=\"#%E7%9B%B8%E5%85%B3%E7%9A%84%E8%A7%86%E9%A2%91\">相关的视频</a></li>\n</ul>","frontmatter":{"title":"React Fiber 架构","date":"2021年09月29日","description":"对文章 React Fiber Architecture 的翻译","tags":["翻译","react","react 原理"]}},"previous":{"fields":{"slug":"/React 组件，元素，和实例/"},"frontmatter":{"title":"React 组件，元素，和实例"}},"next":{"fields":{"slug":"/夏夜晚风/"},"frontmatter":{"title":"夏夜晚风"}}},"pageContext":{"id":"a4673d0f-0c84-5623-a2a3-dc751ff864d0","previousPostId":"be3dc9b7-8e7c-5483-b178-692f00b842e1","nextPostId":"7a86d06e-c5bb-563d-a191-ec443e54cd72"}},"staticQueryHashes":["2792646216","2841359383"]}